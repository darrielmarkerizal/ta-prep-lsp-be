import { defineComponent, computed, createBlock, openBlock, resolveDynamicComponent, normalizeClass, withCtx, createCommentVNode, createElementBlock, createVNode, createSlots, unref, toDisplayString, Fragment, createTextVNode, renderList } from "vue";
import { ScalarMarkdown } from "@scalar/components";
import { isDefined } from "@scalar/helpers/array/is-defined";
import { addWordBreaks } from "@scalar/helpers/string/add-word-breaks";
import { getResolvedRef } from "@scalar/workspace-store/helpers/get-resolved-ref";
import { isArraySchema } from "@scalar/workspace-store/schemas/v3.1/strict/type-guards";
import { isTypeObject } from "./helpers/is-type-object.js";
import { optimizeValueForDisplay } from "./helpers/optimize-value-for-display.js";
import { compositions } from "./helpers/schema-composition.js";
import Schema from "./Schema.vue.js";
import _sfc_main$2 from "./SchemaComposition.vue.js";
import SchemaEnumValues from "./SchemaEnumValues.vue.js";
import SchemaPropertyHeading from "./SchemaPropertyHeading.vue.js";
import _sfc_main$1 from "../../Anchor/WithBreadcrumb.vue2.js";
import _sfc_main$3 from "../../../features/specification-extension/SpecificationExtension.vue2.js";
const _hoisted_1 = {
  key: 0,
  class: "property-name-pattern-properties"
};
const _hoisted_2 = {
  key: 1,
  class: "property-name-additional-properties"
};
const _hoisted_3 = {
  key: 1,
  class: "property-description"
};
const _hoisted_4 = {
  key: 2,
  class: "property-description"
};
const _hoisted_5 = {
  key: 4,
  class: "children"
};
const _hoisted_6 = {
  key: 0,
  class: "children"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "SchemaProperty",
  props: {
    is: {},
    schema: {},
    noncollapsible: { type: Boolean },
    level: { default: 0 },
    name: {},
    required: { type: Boolean, default: false },
    compact: { type: Boolean, default: false },
    discriminator: {},
    description: {},
    hideModelNames: { type: Boolean, default: false },
    hideHeading: { type: Boolean },
    variant: {},
    breadcrumb: {},
    eventBus: {},
    options: {}
  },
  setup(__props) {
    const props = __props;
    const formatLabel = (s) => addWordBreaks(s, { preset: "property" });
    const childBreadcrumb = computed(
      () => props.breadcrumb && props.name ? [...props.breadcrumb, props.name] : void 0
    );
    const descriptions = {
      integer: {
        _default: "Integer numbers.",
        int32: "Signed 32-bit integers (commonly used integer type).",
        int64: "Signed 64-bit integers (long type)."
      },
      string: {
        "date": "full-date notation as defined by RFC 3339, section 5.6, for example, 2017-07-21",
        "date-time": "the date-time notation as defined by RFC 3339, section 5.6, for example, 2017-07-21T17:32:28Z",
        "password": "a hint to UIs to mask the input",
        "base64": "base64-encoded characters, for example, U3dhZ2dlciByb2Nrcw==",
        "byte": "base64-encoded characters, for example, U3dhZ2dlciByb2Nrcw==",
        "binary": "binary data, used to describe files"
      }
    };
    const generatePropertyDescription = (property) => {
      if (!property) {
        return null;
      }
      if (!descriptions[property.type]) {
        return null;
      }
      return descriptions[property.type]?.[property.format || property.contentEncoding || "_default"] || null;
    };
    const getEnumFromValue = (value) => value?.enum || value?.items?.enum || [];
    const optimizedValue = computed(() => optimizeValueForDisplay(props.schema));
    const displayDescription = computed(() => {
      const value = optimizedValue.value;
      if (!value) {
        return null;
      }
      if ("properties" in value) {
        return null;
      }
      if ("additionalProperties" in value) {
        return null;
      }
      if ("patternProperties" in value) {
        return null;
      }
      if (value?.allOf) {
        return null;
      }
      if (value?.allOf) {
        return null;
      }
      return props.description || value?.description || null;
    });
    const displayPropertyHeading = (value, name, required) => {
      return name || value?.deprecated || value?.const !== void 0 || value?.enum && value.enum.length === 1 || value?.type || value?.nullable === true || value?.writeOnly || value?.readOnly || required;
    };
    const hasComplexArrayItems = computed(() => {
      const value = optimizedValue.value;
      if (!value || !isArraySchema(value) || typeof value.items !== "object") {
        return false;
      }
      const items = value.items;
      return "type" in items && items.type && (Array.isArray(items.type) ? items.type.includes("object") : ["object"].includes(items.type)) || "properties" in items || "$ref" in items || "discriminator" in items || "allOf" in items || "oneOf" in items || "anyOf" in items;
    });
    const shouldRenderArrayItemComposition = (composition) => {
      const value = optimizedValue.value;
      if (value && isArraySchema(value) === false || !value?.items || typeof value.items !== "object" || !(composition in value.items)) {
        return false;
      }
      return !hasComplexArrayItems.value;
    };
    const shouldRenderArrayOfObjects = computed(() => hasComplexArrayItems.value);
    const shouldRenderObjectProperties = computed(() => {
      if (!optimizedValue.value) {
        return false;
      }
      const value = optimizedValue.value;
      const isObjectType = isTypeObject(value);
      const hasPropertiesToRender = "properties" in value || "additionalProperties" in value;
      return isObjectType && hasPropertiesToRender;
    });
    const shouldHaveLink = computed(() => props.level <= 1);
    const compositionsToRender = computed(() => {
      if (!optimizedValue.value) {
        return [];
      }
      return compositions.map((composition) => {
        const hasPropertyComposition = optimizedValue.value?.[composition] && !(isArraySchema(optimizedValue.value) && optimizedValue.value?.items && typeof composition === "string" && typeof optimizedValue.value.items === "object" && composition in optimizedValue.value.items);
        if (hasPropertyComposition) {
          return {
            composition,
            value: optimizedValue.value
          };
        }
        if (shouldRenderArrayItemComposition(composition) && optimizedValue.value && isArraySchema(optimizedValue.value) && optimizedValue.value.items) {
          return {
            composition,
            value: optimizedValue.value.items
          };
        }
        return null;
      }).filter(isDefined);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.is ?? "li"), {
        class: normalizeClass(["property", [
          `property--level-${_ctx.level}`,
          {
            "property--compact": _ctx.compact,
            "property--deprecated": optimizedValue.value?.deprecated
          }
        ]])
      }, {
        default: withCtx(() => [
          displayPropertyHeading(optimizedValue.value, _ctx.name, _ctx.required) ? (openBlock(), createBlock(SchemaPropertyHeading, {
            key: 0,
            class: "group",
            enum: getEnumFromValue(optimizedValue.value).length > 0,
            hideModelNames: _ctx.hideModelNames,
            isDiscriminator: _ctx.discriminator && _ctx.discriminator.propertyName === _ctx.name,
            required: _ctx.required,
            value: optimizedValue.value
          }, createSlots({ _: 2 }, [
            _ctx.name ? {
              name: "name",
              fn: withCtx(() => [
                createVNode(unref(_sfc_main$1), {
                  breadcrumb: shouldHaveLink.value ? childBreadcrumb.value : void 0,
                  eventBus: _ctx.eventBus
                }, {
                  default: withCtx(() => [
                    _ctx.variant === "patternProperties" ? (openBlock(), createElementBlock("span", _hoisted_1, toDisplayString(formatLabel(_ctx.name)), 1)) : _ctx.variant === "additionalProperties" ? (openBlock(), createElementBlock("span", _hoisted_2, toDisplayString(formatLabel(_ctx.name)), 1)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                      createTextVNode(toDisplayString(formatLabel(_ctx.name)), 1)
                    ], 64))
                  ]),
                  _: 1
                }, 8, ["breadcrumb", "eventBus"])
              ]),
              key: "0"
            } : void 0,
            optimizedValue.value?.example ? {
              name: "example",
              fn: withCtx(() => [
                createTextVNode(" Example: " + toDisplayString(optimizedValue.value.example), 1)
              ]),
              key: "1"
            } : void 0
          ]), 1032, ["enum", "hideModelNames", "isDiscriminator", "required", "value"])) : createCommentVNode("", true),
          displayDescription.value ? (openBlock(), createElementBlock("div", _hoisted_3, [
            createVNode(unref(ScalarMarkdown), { value: displayDescription.value }, null, 8, ["value"])
          ])) : generatePropertyDescription(optimizedValue.value) ? (openBlock(), createElementBlock("div", _hoisted_4, [
            createVNode(unref(ScalarMarkdown), {
              value: generatePropertyDescription(optimizedValue.value) || ""
            }, null, 8, ["value"])
          ])) : createCommentVNode("", true),
          (optimizedValue.value?.enum || optimizedValue.value && unref(isArraySchema)(optimizedValue.value) && unref(getResolvedRef)(optimizedValue.value?.items)?.enum || []).length ? (openBlock(), createBlock(SchemaEnumValues, {
            key: 3,
            value: optimizedValue.value
          }, null, 8, ["value"])) : createCommentVNode("", true),
          shouldRenderObjectProperties.value ? (openBlock(), createElementBlock("div", _hoisted_5, [
            createVNode(Schema, {
              breadcrumb: childBreadcrumb.value,
              compact: _ctx.compact,
              eventBus: _ctx.eventBus,
              level: _ctx.level + 1,
              name: _ctx.name,
              noncollapsible: _ctx.noncollapsible,
              options: _ctx.options,
              schema: optimizedValue.value
            }, null, 8, ["breadcrumb", "compact", "eventBus", "level", "name", "noncollapsible", "options", "schema"])
          ])) : createCommentVNode("", true),
          optimizedValue.value && unref(isArraySchema)(optimizedValue.value) && typeof optimizedValue.value.items === "object" ? (openBlock(), createElementBlock(Fragment, { key: 5 }, [
            shouldRenderArrayOfObjects.value ? (openBlock(), createElementBlock("div", _hoisted_6, [
              createVNode(Schema, {
                compact: _ctx.compact,
                eventBus: _ctx.eventBus,
                level: _ctx.level + 1,
                name: _ctx.name,
                noncollapsible: _ctx.noncollapsible,
                options: _ctx.options,
                schema: unref(getResolvedRef)(optimizedValue.value.items)
              }, null, 8, ["compact", "eventBus", "level", "name", "noncollapsible", "options", "schema"])
            ])) : createCommentVNode("", true)
          ], 64)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(compositionsToRender.value, (compositionData) => {
            return openBlock(), createBlock(_sfc_main$2, {
              key: compositionData.composition,
              breadcrumb: _ctx.breadcrumb,
              compact: _ctx.compact,
              composition: compositionData.composition,
              discriminator: _ctx.schema?.discriminator,
              eventBus: _ctx.eventBus,
              hideHeading: _ctx.hideHeading,
              level: _ctx.level,
              name: _ctx.name,
              noncollapsible: _ctx.noncollapsible,
              options: _ctx.options,
              schema: unref(getResolvedRef)(props.schema)
            }, null, 8, ["breadcrumb", "compact", "composition", "discriminator", "eventBus", "hideHeading", "level", "name", "noncollapsible", "options", "schema"]);
          }), 128)),
          createVNode(unref(_sfc_main$3), { value: optimizedValue.value }, null, 8, ["value"])
        ]),
        _: 1
      }, 8, ["class"]);
    };
  }
});
export {
  _sfc_main as default
};
