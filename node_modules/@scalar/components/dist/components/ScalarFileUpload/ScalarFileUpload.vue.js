import { defineComponent as E, mergeModels as m, useModel as p, ref as c, createElementBlock as v, openBlock as r, mergeProps as F, unref as s, withModifiers as g, renderSlot as a, createCommentVNode as y, createBlock as $, createElementVNode as T, resolveDynamicComponent as w, createSlots as k, withCtx as n, createVNode as b, createTextVNode as A, toDisplayString as j } from "vue";
import { useBindCx as L } from "@scalar/use-hooks/useBindCx";
import P from "./ScalarFileUploadDropTarget.vue.js";
import U from "./ScalarFileUploadError.vue.js";
import _ from "./ScalarFileUploadInput.vue.js";
import q from "./ScalarFileUploadInputCompact.vue.js";
import z from "./ScalarFileUploadLoading.vue.js";
import { isExtensionList as h } from "./types.js";
const G = ["accept", "multiple"], H = {}, Y = /* @__PURE__ */ E({
  ...H,
  inheritAttrs: !1,
  __name: "ScalarFileUpload",
  props: /* @__PURE__ */ m({
    multiple: { type: Boolean },
    accept: { default: "*" },
    loader: {},
    variant: { default: "default" }
  }, {
    modelValue: {},
    modelModifiers: {},
    error: {},
    errorModifiers: {}
  }),
  emits: /* @__PURE__ */ m(["selected"], ["update:modelValue", "update:error"]),
  setup(i, { emit: C }) {
    const D = C, V = p(i, "modelValue"), l = p(i, "error"), d = c(), t = c(!1);
    function u() {
      d.value?.click();
    }
    function f(e) {
      if (l.value = void 0, !e || e.length < 1) {
        l.value = "No files found to upload";
        return;
      }
      const o = Array.from(e);
      if (!i.multiple && o.length > 1) {
        l.value = "Too many files selected";
        return;
      }
      V.value = o, D("selected", o);
    }
    function B(e) {
      const o = e.target.files;
      f(o);
    }
    function M(e) {
      t.value = !1, f(e.dataTransfer?.files);
    }
    const { cx: N } = L();
    return (e, o) => (r(), v("div", F(
      s(N)(
        "flex flex-col relative border-dashed border-1 has-[input:focus-visible]:outline outline-offset-1 rounded"
      ),
      {
        onDragenter: o[1] || (o[1] = (S) => t.value = !0),
        onDragover: o[2] || (o[2] = g(() => {
        }, ["prevent"])),
        onDrop: g(M, ["prevent"])
      }
    ), [
      a(e.$slots, "default", { open: u }, () => [
        (r(), $(w(
          e.variant === "compact" ? q : _
        ), {
          extensions: s(h)(e.accept) ? e.accept : void 0,
          onClick: u
        }, k({ _: 2 }, [
          e.$slots.label ? {
            name: "default",
            fn: n(() => [
              a(e.$slots, "label")
            ]),
            key: "0"
          } : void 0,
          l.value ? {
            name: "sublabel",
            fn: n(() => [
              b(U, null, {
                default: n(() => [
                  A(j(l.value), 1)
                ]),
                _: 1
              })
            ]),
            key: "1"
          } : void 0
        ]), 1032, ["extensions"]))
      ]),
      t.value ? (r(), v("div", {
        key: 0,
        class: "absolute inset-0",
        onDragleave: o[0] || (o[0] = (S) => t.value = !1)
      }, [
        a(e.$slots, "drop-target", {}, () => [
          b(P, null, k({ _: 2 }, [
            e.$slots["drop-target-label"] ? {
              name: "default",
              fn: n(() => [
                a(e.$slots, "drop-target-label")
              ]),
              key: "0"
            } : void 0
          ]), 1024)
        ])
      ], 32)) : y("", !0),
      e.loader?.isLoading ? (r(), $(z, {
        key: 1,
        loader: e.loader
      }, null, 8, ["loader"])) : y("", !0),
      T("input", {
        ref_key: "input",
        ref: d,
        accept: s(h)(e.accept) ? e.accept.join(",") : e.accept,
        class: "sr-only",
        multiple: e.multiple,
        type: "file",
        onChange: B
      }, null, 40, G)
    ], 16));
  }
});
export {
  Y as default
};
