import { defineComponent as W, mergeModels as O, useModel as X, useSlots as Y, useId as z, computed as w, ref as M, onMounted as D, watch as Z, createElementBlock as c, openBlock as s, Fragment as m, createElementVNode as k, withDirectives as G, createVNode as I, unref as h, withKeys as V, withModifiers as y, vModelText as _, createBlock as C, createCommentVNode as K, renderList as q, withCtx as x, renderSlot as S, toDisplayString as F, createTextVNode as ee, vShow as te } from "vue";
import { ScalarIconMagnifyingGlass as le, ScalarIconPlus as oe } from "@scalar/icons";
import P from "./ScalarComboboxOption.vue.js";
import ie from "./ScalarComboboxOptionGroup.vue.js";
import { isGroups as U } from "./types.js";
import ne from "../ScalarListbox/ScalarListboxCheckbox.vue.js";
const ae = { class: "relative flex" }, se = ["aria-activedescendant", "placeholder"], de = ["aria-multiselectable"], ue = { class: "inline-block min-w-0 flex-1 truncate text-c-1" }, be = /* @__PURE__ */ W({
  inheritAttrs: !1,
  __name: "ScalarComboboxOptions",
  props: /* @__PURE__ */ O({
    options: {},
    placeholder: {},
    multiselect: { type: Boolean }
  }, {
    modelValue: { default: [] },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ O(["add"], ["update:modelValue"]),
  setup(B, { emit: j }) {
    const d = B, H = j, n = X(B, "modelValue"), g = Y(), $ = `scalar-combobox-items-${z()}`, f = { id: `${z()}-add`, label: "Add a new option" };
    function p(t) {
      return `${$}-${t.id}`;
    }
    const r = w(
      () => U(d.options) ? d.options.flatMap((t) => t.options) : d.options
    ), J = w(
      () => U(d.options) ? d.options : (
        /*
          We know G is an unextended OptionGroup<O> here because of the
          structure of the component props so we can cast it to G
        */
        [{ label: "", options: d.options }]
      )
      // G is OptionGroup<O>
    ), u = M(""), l = M(n.value?.[0] ?? r.value[0]);
    D(() => {
      u.value = "", l.value = n.value?.[0] ?? r.value[0], n.value[0] && setTimeout(() => {
        const e = n.value[0];
        e && document?.getElementById(p(e))?.scrollIntoView({ block: "nearest" });
      }, 10);
    }), Z(
      () => u.value,
      () => l.value = N.value[0]
    );
    const b = w(
      () => u.value === "" ? r.value : r.value.filter((t) => t.label.toLowerCase().includes(u.value.toLowerCase()))
    ), N = w(
      () => g.add ? [...b.value, f] : b.value
    );
    function A(t) {
      if (t) {
        if (t.id === f.id) {
          T();
          return;
        }
        d.multiselect ? n.value.some((e) => e.id === t.id) ? n.value = n.value.filter((e) => e.id !== t.id) : n.value = [
          ...n.value,
          r.value.find((e) => e.id === t.id)
        ] : n.value = [r.value.find((e) => e.id === t.id)];
      }
    }
    function E(t) {
      const e = N.value, v = e.findIndex((i) => i.id === l.value?.id) + t;
      v < 0 || v > e.length - 1 || (l.value = e[v], l.value && document?.getElementById(p(l.value))?.scrollIntoView({
        behavior: "smooth",
        block: "nearest"
      }));
    }
    function T() {
      H("add"), u.value = "";
    }
    const L = M(null);
    return D(() => setTimeout(() => L.value?.focus(), 0)), (t, e) => (s(), c(m, null, [
      k("div", ae, [
        I(h(le), { class: "pointer-events-none absolute left-2.5 top-1/2 -translate-y-1/2 text-c-3 size-4" }),
        G(k("input", {
          ref_key: "input",
          ref: L,
          "onUpdate:modelValue": e[0] || (e[0] = (o) => u.value = o),
          "aria-activedescendant": l.value ? p(l.value) : void 0,
          "aria-autocomplete": "list",
          "aria-controls": $,
          class: "min-w-0 flex-1 rounded border-0 py-2.5 pl-8 pr-3 leading-none text-c-1 -outline-offset-1",
          "data-1p-ignore": "",
          placeholder: t.placeholder,
          role: "combobox",
          tabindex: "0",
          type: "text",
          onKeydown: [
            e[1] || (e[1] = V(y((o) => E(1), ["prevent"]), ["down"])),
            e[2] || (e[2] = V(y((o) => l.value && A(l.value), ["prevent"]), ["enter"])),
            e[3] || (e[3] = V(y((o) => E(-1), ["prevent"]), ["up"]))
          ]
        }, null, 40, se), [
          [_, u.value]
        ])
      ]),
      G(k("ul", {
        id: $,
        "aria-multiselectable": t.multiselect,
        class: "border-t p-0.75 custom-scroll overscroll-contain flex-1 min-h-0",
        role: "listbox",
        tabindex: "-1"
      }, [
        (s(!0), c(m, null, q(J.value, (o, v) => (s(), C(ie, {
          id: `${$}-group-${v}`,
          key: v,
          hidden: (
            // Only show the group label if there are some results
            !o.options.some((i) => b.value.some((a) => a.id === i.id)) || // And it has a label
            !o.label
          )
        }, {
          label: x(() => [
            t.$slots.group ? S(t.$slots, "group", {
              key: 0,
              group: o
            }) : (s(), c(m, { key: 1 }, [
              ee(F(o.label), 1)
            ], 64))
          ]),
          default: x(() => [
            (s(!0), c(m, null, q(b.value, (i) => (s(), c(m, {
              key: i.id
            }, [
              o.options.some((a) => a.id === i.id) ? (s(), C(P, {
                key: 0,
                id: p(i),
                active: l.value?.id === i.id,
                selected: n.value.some((a) => a.id === i.id),
                onClick: (a) => A(i),
                onMousedown: e[4] || (e[4] = y(() => {
                }, ["prevent"])),
                onMouseenter: (a) => l.value = i
              }, {
                default: x(({ active: a, selected: Q }) => [
                  t.$slots.option ? S(t.$slots, "option", {
                    key: 0,
                    active: a,
                    option: i,
                    selected: Q
                  }) : (s(), c(m, { key: 1 }, [
                    I(h(ne), {
                      multiselect: t.multiselect,
                      selected: n.value.some((R) => R.id === i.id)
                    }, null, 8, ["multiselect", "selected"]),
                    k("span", ue, F(i.label), 1)
                  ], 64))
                ]),
                _: 2
              }, 1032, ["id", "active", "selected", "onClick", "onMouseenter"])) : K("", !0)
            ], 64))), 128))
          ]),
          _: 2
        }, 1032, ["id", "hidden"]))), 128)),
        g.add ? (s(), C(P, {
          key: 0,
          id: p(f),
          active: l.value?.id === f.id,
          onClick: T,
          onMousedown: e[5] || (e[5] = y(() => {
          }, ["prevent"])),
          onMouseenter: e[6] || (e[6] = (o) => l.value = f)
        }, {
          default: x(({ active: o }) => [
            I(h(oe), { class: "size-4 p-px" }),
            S(t.$slots, "add", { active: o })
          ]),
          _: 3
        }, 8, ["id", "active"])) : K("", !0)
      ], 8, de), [
        [te, b.value.length || g.add]
      ])
    ], 64));
  }
});
export {
  be as default
};
