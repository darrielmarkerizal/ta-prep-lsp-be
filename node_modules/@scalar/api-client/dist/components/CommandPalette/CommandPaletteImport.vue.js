import { defineComponent as J, ref as L, computed as x, watch as A, createBlock as I, openBlock as l, unref as r, withCtx as p, createElementBlock as d, Fragment as v, createElementVNode as U, createCommentVNode as Y, createVNode as w, createTextVNode as c, toDisplayString as R } from "vue";
import { useLoadingState as q, ScalarButton as D, ScalarCodeBlock as G, ScalarIcon as H, ScalarTooltip as K } from "@scalar/components";
import { useToasts as Q } from "@scalar/use-toasts";
import { useRouter as X } from "vue-router";
import { importCurlCommand as Z } from "../../libs/importers/curl.js";
import { PathId as O } from "../../routes.js";
import { useActiveEntities as ee } from "../../store/active-entities.js";
import te from "./CommandActionForm.vue.js";
import oe from "./CommandActionInput.vue.js";
import ae from "./WatchModeToggle.vue.js";
import { isPostmanCollection as P, getPostmanDocumentDetails as le, convertPostmanToOpenApi as V } from "../../libs/postman.js";
import { getOpenApiDocumentDetails as re } from "../../libs/getOpenApiDocumentDetails.js";
import { isUrl as h } from "../../libs/isUrl.js";
import { useFileDialog as ne } from "../../hooks/useFileDialog.js";
import { useWorkspace as ie } from "../../store/store.js";
const se = { class: "flex justify-between" }, ue = { class: "flex w-full flex-row items-center justify-between gap-3" }, Pe = /* @__PURE__ */ J({
  __name: "CommandPaletteImport",
  emits: ["close", "back"],
  setup(ce, { emit: T }) {
    const C = T, _ = X(), { activeWorkspace: n, activeCollection: F } = ee(), { importSpecFile: k, importSpecFromUrl: W, events: N } = ie(), { toast: i } = Q(), s = q(), o = L(""), f = L(!0), a = x(() => P(o.value) ? le(o.value) : re(o.value)), S = x(
      () => a.value ? a.value.type : "json"
    );
    function g(e) {
      e && _.push({
        name: "collection",
        params: {
          [O.Workspace]: n.value?.uid,
          [O.Collection]: e.uid
        }
      });
    }
    const y = x(() => h(o.value)), $ = x(() => !!a.value), { open: B } = ne({
      onChange: (e) => {
        const t = e?.[0];
        if (t) {
          const u = new FileReader();
          u.onload = async (E) => {
            const b = E.target?.result;
            try {
              if (P(b)) {
                const m = await k(
                  V(b),
                  n.value?.uid ?? ""
                );
                g(m?.collection);
              } else {
                const m = await k(
                  b,
                  n.value?.uid ?? ""
                );
                g(m?.collection);
              }
              i("Import successful", "info"), C("close");
            } catch (m) {
              console.error(m);
              const z = m?.message || "Unknown error";
              i(`Import failed: ${z}`, "error");
            }
          }, u.readAsText(t);
        }
      },
      multiple: !1,
      accept: ".json,.yaml,.yml"
    });
    A(y, (e) => {
      e || (f.value = !1);
    }), A(o, (e) => {
      h(e) || (f.value = !1);
    });
    async function M() {
      if (!(!o.value || s.isLoading)) {
        s.startLoading();
        try {
          if (y.value) {
            const [e, t] = await W(
              o.value,
              n.value?.uid ?? "",
              {
                proxyUrl: n.value?.proxyUrl,
                watchMode: f.value
              }
            );
            if (g(t?.collection), e) {
              i(
                "There was a possible CORS error while importing your spec, please make sure this server is allowed in the CORS policy of your OpenAPI document.",
                "error",
                { timeout: 5e3 }
              ), s.invalidate(2e3, !0);
              return;
            }
          } else if ($.value)
            if (P(o.value)) {
              const e = await k(
                V(o.value),
                n.value?.uid ?? ""
              );
              g(e?.collection), i("Successfully converted Postman collection", "info");
            } else {
              const e = await k(
                o.value,
                n.value?.uid ?? ""
              );
              g(e?.collection);
            }
          else {
            i("Import failed: Invalid URL or OpenAPI document", "error"), s.invalidate(2e3, !0);
            return;
          }
          s.clear(), C("close"), i("Import successful", "info");
        } catch (e) {
          console.error("[importCollection]", e);
          const t = e?.message || "Unknown error";
          s.invalidate(2e3, !0), i(`Import failed: ${t}`, "error");
        }
      }
    }
    const j = (e) => {
      if (e.trim().toLowerCase().startsWith("curl")) {
        N.commandPalette.emit({
          commandName: "Import from cURL",
          metaData: {
            parsedCurl: Z(e),
            collectionUid: F.value?.uid
          }
        });
        return;
      }
      o.value = e;
    };
    return (e, t) => (l(), I(te, {
      disabled: !o.value.trim(),
      loading: r(s),
      onSubmit: M
    }, {
      options: p(() => [
        U("div", ue, [
          w(r(D), {
            class: "hover:bg-b-2 relative max-h-8 gap-1.5 p-2 text-xs",
            variant: "outlined",
            onClick: r(B)
          }, {
            default: p(() => [
              t[5] || (t[5] = c(" JSON, or YAML File ", -1)),
              w(r(H), {
                class: "text-c-3",
                icon: "Upload",
                size: "md"
              })
            ]),
            _: 1
          }, 8, ["onClick"]),
          w(r(K), {
            content: y.value ? "Watch mode automatically updates the API client when the OpenAPI URL content changes, ensuring your client remains up-to-date." : "Watch mode is only available for URL imports. When enabled it automatically updates the API client when the OpenAPI URL content changes.",
            placement: "bottom"
          }, {
            default: p(() => [
              w(ae, {
                modelValue: f.value,
                "onUpdate:modelValue": t[2] || (t[2] = (u) => f.value = u),
                disabled: !y.value
              }, null, 8, ["modelValue", "disabled"])
            ]),
            _: 1
          }, 8, ["content"])
        ])
      ]),
      submit: p(() => [
        t[6] || (t[6] = c(" Import ", -1)),
        y.value ? (l(), d(v, { key: 0 }, [
          c(" from URL ")
        ], 64)) : a.value && S.value ? (l(), d(v, { key: 1 }, [
          a.value.title ? (l(), d(v, { key: 0 }, [
            c(' "' + R(a.value.title) + '" ', 1)
          ], 64)) : (l(), d(v, { key: 1 }, [
            c(R(a.value.version), 1)
          ], 64))
        ], 64)) : (l(), d(v, { key: 2 }, [
          c(" Collection ")
        ], 64))
      ]),
      default: p(() => [
        !a.value || r(h)(o.value) ? (l(), I(oe, {
          key: 0,
          modelValue: o.value,
          placeholder: "OpenAPI/Swagger/Postman URL or cURL",
          onOnDelete: t[0] || (t[0] = (u) => C("back", u)),
          "onUpdate:modelValue": j
        }, null, 8, ["modelValue"])) : (l(), d(v, { key: 1 }, [
          U("div", se, [
            t[4] || (t[4] = U("div", { class: "text-c-2 min-h-8 w-full py-2 pl-12 text-center text-xs" }, " Preview ", -1)),
            w(r(D), {
              class: "hover:bg-b-2 relative ml-auto max-h-8 gap-1.5 p-2 text-xs",
              variant: "ghost",
              onClick: t[1] || (t[1] = (u) => o.value = "")
            }, {
              default: p(() => [...t[3] || (t[3] = [
                c(" Clear ", -1)
              ])]),
              _: 1
            })
          ]),
          a.value && !r(h)(o.value) ? (l(), I(r(G), {
            key: 0,
            class: "bg-b-2 mt-1 max-h-[40dvh] rounded border px-2 py-1 text-sm",
            content: o.value,
            copy: !1,
            lang: S.value
          }, null, 8, ["content", "lang"])) : Y("", !0)
        ], 64))
      ]),
      _: 1
    }, 8, ["disabled", "loading"]));
  }
});
export {
  Pe as default
};
