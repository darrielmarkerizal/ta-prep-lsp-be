import { isDefined as v } from "@scalar/helpers/array/is-defined";
import { getRaw as S } from "@scalar/json-magic/magic-proxy";
import { getResolvedRef as m } from "@scalar/workspace-store/helpers/get-resolved-ref";
import { unpackOverridesProxy as N } from "@scalar/workspace-store/helpers/overrides-proxy";
const T = 10, j = 10, D = "propertyName*", A = (/* @__PURE__ */ new Date()).toISOString(), q = A.split("T")[0], k = A.split("T")[1].split(".")[0], I = {
  "date-time": A,
  date: q,
  email: "hello@example.com",
  hostname: "example.com",
  // https://tools.ietf.org/html/rfc6531#section-3.3
  "idn-email": "jane.doe@example.com",
  // https://tools.ietf.org/html/rfc5890#section-2.3.2.3
  "idn-hostname": "example.com",
  ipv4: "127.0.0.1",
  ipv6: "51d4:7fab:bfbf:b7d7:b2cb:d4b4:3dad:d998",
  "iri-reference": "/entitiy/1",
  // https://tools.ietf.org/html/rfc3987
  iri: "https://example.com/entity/123",
  "json-pointer": "/nested/objects",
  password: "super-secret",
  regex: "/[a-z]/",
  // https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01
  "relative-json-pointer": "1/nested/objects",
  // full-time in https://tools.ietf.org/html/rfc3339#section-5.6
  time: k,
  // either a URI or relative-reference https://tools.ietf.org/html/rfc3986#section-4.1
  "uri-reference": "../folder",
  "uri-template": "https://example.com/{id}",
  uri: "https://example.com",
  uuid: "123e4567-e89b-12d3-a456-426614174000",
  "object-id": "6592008029c8c3e4dc76256c"
}, E = (e, r = !1, l = "") => "type" in e && e.type === "string" && "format" in e && e.format === "binary" ? new File([""], "filename") : r && "format" in e && e.format ? I[e.format] ?? l : l, O = /* @__PURE__ */ new WeakMap(), P = /* @__PURE__ */ new WeakMap(), M = (e) => {
  if (!e)
    return;
  const r = P.get(e);
  if (r)
    return r;
  if ("required" in e) {
    const l = e.required;
    if (Array.isArray(l) && l.length > 0) {
      const a = new Set(l);
      return P.set(e, a), a;
    }
  }
}, d = (e, r) => (typeof r != "object" || r === null || O.set(S(N(e)), r), r), _ = (e) => !!(e.allOf || e.oneOf || e.anyOf), C = (e, r, l, a) => {
  if (a?.omitEmptyAndOptionalProperties !== !0 || "type" in e && (e.type === "object" || e.type === "array") || _(e) || "examples" in e && Array.isArray(e.examples) && e.examples.length > 0 || "example" in e && e.example !== void 0 || "default" in e && e.default !== void 0 || "const" in e && e.const !== void 0 || "enum" in e && Array.isArray(e.enum) && e.enum.length > 0)
    return !1;
  const o = l ?? e.title ?? "", i = M(r);
  return !(i ? i.has(o) : !1);
}, R = (e, r) => Array.isArray(e) && Array.isArray(r) ? [...e, ...r] : e && typeof e == "object" && r && typeof r == "object" ? { ...e, ...r } : r, F = (e, r, l, a) => {
  const n = {};
  if ("properties" in e && e.properties) {
    const o = Object.keys(e.properties), i = l > 3 ? Math.min(j, o.length) : o.length;
    for (let t = 0; t < i; t++) {
      const p = o[t], u = m(e.properties[p]);
      if (!u)
        continue;
      const c = r?.xml && "xml" in u ? u.xml?.name : void 0, y = s(u, r, {
        level: l + 1,
        parentSchema: e,
        name: p,
        seen: a
      });
      typeof y < "u" && (n[c ?? p] = y);
    }
    l > 3 && o.length > j && (n["..."] = "[Additional Properties Truncated]");
  }
  if ("patternProperties" in e && e.patternProperties)
    for (const o of Object.keys(e.patternProperties)) {
      const i = m(e.patternProperties[o]);
      i && (n[o] = s(i, r, {
        level: l + 1,
        parentSchema: e,
        name: o,
        seen: a
      }));
    }
  if ("additionalProperties" in e && e.additionalProperties) {
    const o = m(e.additionalProperties), i = e.additionalProperties === !0 || typeof e.additionalProperties == "object" && Object.keys(e.additionalProperties).length === 0, t = typeof o == "object" && "x-additionalPropertiesName" in o && typeof o["x-additionalPropertiesName"] == "string" && o["x-additionalPropertiesName"].trim().length > 0 ? `${o["x-additionalPropertiesName"].trim()}*` : D;
    n[t] = i ? "anything" : typeof o == "object" ? s(o, r, {
      level: l + 1,
      seen: a
    }) : "anything";
  }
  if (e.oneOf?.[0])
    Object.assign(
      n,
      s(m(e.oneOf[0]), r, {
        level: l + 1,
        seen: a
      })
    );
  else if (e.anyOf?.[0])
    Object.assign(
      n,
      s(m(e.anyOf[0]), r, {
        level: l + 1,
        seen: a
      })
    );
  else if (Array.isArray(e.allOf) && e.allOf.length > 0) {
    let o = n;
    for (const i of e.allOf) {
      const t = s(m(i), r, {
        level: l + 1,
        parentSchema: e,
        seen: a
      });
      o = R(o, t);
    }
    o && typeof o == "object" && Object.assign(n, o);
  }
  if (r?.xml && "xml" in e && e.xml?.name && l === 0) {
    const o = {};
    return o[e.xml.name] = n, d(e, o);
  }
  return d(e, n);
}, L = (e, r, l, a) => {
  const n = "items" in e ? m(e.items) : void 0, o = n && typeof n == "object" && "xml" in n ? n.xml?.name : void 0, i = !!(r?.xml && "xml" in e && e.xml?.wrapped && o);
  if (e.example !== void 0)
    return d(e, i ? { [o]: e.example } : e.example);
  if (n && typeof n == "object") {
    if (Array.isArray(n.allOf) && n.allOf.length > 0) {
      const c = n.allOf.filter(v), y = m(c[0]);
      if (y && typeof y == "object" && "type" in y && y.type === "object") {
        const x = s({ type: "object", allOf: c }, r, {
          level: l + 1,
          parentSchema: e,
          seen: a
        });
        return d(e, i ? [{ [o]: x }] : [x]);
      }
      const g = c.map(
        (f) => s(m(f), r, {
          level: l + 1,
          parentSchema: e,
          seen: a
        })
      ).filter(v);
      return d(
        e,
        i ? g.map((f) => ({ [o]: f })) : g
      );
    }
    const u = n.anyOf || n.oneOf;
    if (u && u.length > 0) {
      const c = u[0], y = s(m(c), r, {
        level: l + 1,
        parentSchema: e,
        seen: a
      });
      return d(e, i ? [{ [o]: y }] : [y]);
    }
  }
  const t = n && typeof n == "object" && ("type" in n && n.type === "object" || "properties" in n), p = n && typeof n == "object" && ("type" in n && n.type === "array" || "items" in n);
  if (n && typeof n == "object" && ("type" in n && n.type || t || p)) {
    const u = s(n, r, {
      level: l + 1,
      seen: a
    });
    return d(e, i ? [{ [o]: u }] : [u]);
  }
  return d(e, []);
}, X = (e, r, l) => {
  if ("type" in e && e.type && !Array.isArray(e.type))
    switch (e.type) {
      case "string":
        return E(e, r, l ?? "");
      case "boolean":
        return !0;
      case "integer":
        return "minimum" in e && typeof e.minimum == "number" ? e.minimum : 1;
      case "number":
        return "minimum" in e && typeof e.minimum == "number" ? e.minimum : 1;
      case "array":
        return [];
      default:
        return;
    }
}, U = (e, r, l) => {
  if ("type" in e && Array.isArray(e.type)) {
    if (e.type.includes("null"))
      return null;
    const a = e.type[0];
    if (a)
      switch (a) {
        case "string":
          return E(e, r, l ?? "");
        case "boolean":
          return !0;
        case "integer":
          return "minimum" in e && typeof e.minimum == "number" ? e.minimum : 1;
        case "number":
          return "minimum" in e && typeof e.minimum == "number" ? e.minimum : 1;
        case "null":
          return null;
        default:
          return;
      }
  }
}, s = (e, r, l) => {
  const { level: a = 0, parentSchema: n, name: o, seen: i = /* @__PURE__ */ new WeakSet() } = l ?? {}, t = m(e);
  if (!v(t))
    return;
  const p = S(N(t));
  if (i.has(p))
    return "[Circular Reference]";
  if (i.add(p), O.has(p))
    return i.delete(p), O.get(p);
  if (a > T)
    return i.delete(p), "[Max Depth Exceeded]";
  const u = !!r?.emptyString;
  if (t.deprecated || r?.mode === "write" && t.readOnly || r?.mode === "read" && t.writeOnly || C(t, n, o, r)) {
    i.delete(p);
    return;
  }
  if ("x-variable" in t && t["x-variable"]) {
    const f = r?.variables?.[t["x-variable"]];
    if (f !== void 0)
      return "type" in t && (t.type === "number" || t.type === "integer") ? (i.delete(p), d(t, Number(f))) : (i.delete(p), d(t, f));
  }
  if (Array.isArray(t.examples) && t.examples.length > 0)
    return i.delete(p), d(t, t.examples[0]);
  if (t.example !== void 0)
    return i.delete(p), d(t, t.example);
  if (t.default !== void 0)
    return i.delete(p), d(t, t.default);
  if (t.const !== void 0)
    return i.delete(p), d(t, t.const);
  if (Array.isArray(t.enum) && t.enum.length > 0)
    return i.delete(p), d(t, t.enum[0]);
  if ("properties" in t || "type" in t && t.type === "object") {
    const f = F(t, r, a, i);
    return i.delete(p), f;
  }
  if ("type" in t && t.type === "array" || "items" in t) {
    const f = L(t, r, a, i);
    return i.delete(p), f;
  }
  const c = X(t, u, r?.emptyString);
  if (c !== void 0)
    return i.delete(p), d(t, c);
  const y = t.oneOf || t.anyOf;
  if (Array.isArray(y) && y.length > 0) {
    for (const f of y) {
      const x = m(f);
      if (x && (!("type" in x) || x.type !== "null"))
        return i.delete(p), d(
          t,
          s(x, r, {
            level: a + 1,
            seen: i
          })
        );
    }
    return i.delete(p), d(t, null);
  }
  if (Array.isArray(t.allOf) && t.allOf.length > 0) {
    let f;
    const x = t.allOf;
    for (const w of x) {
      const b = s(w, r, {
        level: a + 1,
        parentSchema: t,
        seen: i
      });
      f === void 0 ? f = b : f && typeof f == "object" && b && typeof b == "object" ? f = R(f, b) : b !== void 0 && (f = b);
    }
    return i.delete(p), d(t, f ?? null);
  }
  const g = U(t, u, r?.emptyString);
  return g !== void 0 ? (i.delete(p), d(t, g)) : (i.delete(p), d(t, null));
};
export {
  s as getExampleFromSchema
};
