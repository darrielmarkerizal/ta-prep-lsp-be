import { isDefined as Y, mergeUrls as G, shouldUseProxy as T, redirectToProxy as J, httpStatusCodes as N } from "@scalar/oas-utils/helpers";
import { isElectron as H } from "../electron.js";
import { ERRORS as P, normalizeError as U } from "../errors.js";
import { normalizeHeaders as Z } from "../normalize-headers.js";
import { createFetchBody as $ } from "./create-fetch-body.js";
import { createFetchHeaders as M } from "./create-fetch-headers.js";
import { createFetchQueryParams as ee } from "./create-fetch-query-params.js";
import { decodeBuffer as te } from "./decode-buffer.js";
import { setRequestCookies as oe, getCookieHeader as re } from "./set-request-cookies.js";
import { replaceTemplateVariables as c } from "../string-template.js";
import { buildRequestSecurity as se } from "./build-request-security.js";
const we = ({
  environment: q,
  example: s,
  globalCookies: v,
  proxyUrl: u,
  request: a,
  securitySchemes: D,
  selectedSecuritySchemeUids: E = [],
  server: k,
  status: m,
  pluginManager: h
}) => {
  try {
    const o = q ?? {}, w = new AbortController(), b = s.parameters.path.reduce((t, e) => (e.enabled && (t[e.key] = c(e.value, o)), t), {}), L = c(k?.url ?? "", o), l = c(c(a.path, o), b);
    let r = L || l;
    if (!r)
      throw P.URL_EMPTY;
    Object.entries(k?.variables ?? {}).forEach(([t, e]) => {
      r = c(r, {
        [t]: b[t] || e.default
      });
    });
    const z = ee(s, o, a), B = M(s, o), { body: F } = $(a.method, s, o), { cookieParams: _ } = oe({
      example: s,
      env: o,
      globalCookies: v,
      serverUrl: r,
      proxyUrl: u
    }), O = E.flat().map((t) => D[t]).filter(Y), f = se(O, o), n = { ...Object.entries(f.headers).reduce(
      (t, [e, S]) => (t[e.toLowerCase()] = S, t),
      {}
    ), ...B }, W = [..._, ...f.cookies], x = new URLSearchParams([...z, ...f.urlParams]);
    H() && n["user-agent"] && (n["X-Scalar-User-Agent"] = n["user-agent"]), r = G(r, l, x);
    const p = c(re(W, n.Cookie), o);
    p && (H() || T(u, r) ? (console.warn(
      "We're using a `X-Scalar-Cookie` custom header to the request. The proxy will forward this as a `Cookie` header. We do this to avoid the browser omitting the `Cookie` header for cross-origin requests for security reasons."
    ), n["X-Scalar-Cookie"] = p) : (console.warn(
      `We're trying to add a Cookie header, but browsers often omit them for cross-origin requests for various security reasons. If it's not working, that's probably why. Here are the requirements for it to work:

          - The browser URL must be on the same domain as the server URL.
          - The connection must be made over HTTPS.
          `
    ), n.Cookie = p));
    const A = J(u, r), y = new Request(A, {
      method: a.method.toUpperCase(),
      body: F ?? null,
      headers: n
    });
    return [
      null,
      {
        request: y,
        sendRequest: async () => {
          m?.emit("start"), h && await h.executeHook("onBeforeRequest", { request: y });
          const t = Date.now();
          try {
            const e = await fetch(y, {
              signal: w.signal
            }), S = e.headers.get("content-type")?.startsWith("text/event-stream");
            m?.emit("stop");
            const X = Date.now() - t, j = e.clone(), R = Z(e.headers, T(u, r)), I = e.headers.get("content-type") ?? "text/plain;charset=UTF-8", C = await j.arrayBuffer(), Q = te(C, I), i = e.clone(), V = i.statusText || N[i.status]?.name || "", K = [204, 205, 304].includes(i.status), d = new Response(K ? null : i.body, {
              status: i.status,
              statusText: V,
              headers: i.headers
            });
            h && await h.executeHook("onResponseReceived", { response: d, operation: a });
            const g = "getSetCookie" in d.headers && typeof d.headers.getSetCookie == "function" ? d.headers.getSetCookie() : [];
            return S && e.body ? [
              null,
              {
                timestamp: Date.now(),
                request: s,
                response: {
                  ...d,
                  headers: R,
                  cookieHeaderKeys: g,
                  reader: e.body?.getReader(),
                  duration: X,
                  method: a.method,
                  path: l
                }
              }
            ] : [
              null,
              {
                timestamp: Date.now(),
                request: s,
                response: {
                  ...e,
                  headers: R,
                  cookieHeaderKeys: g,
                  data: Q,
                  size: C.byteLength,
                  duration: Date.now() - t,
                  method: a.method,
                  status: e.status,
                  path: l
                }
              }
            ];
          } catch (e) {
            return m?.emit("abort"), [U(e, P.REQUEST_FAILED), null];
          }
        },
        controller: w
      }
    ];
  } catch (o) {
    return console.error(o), m?.emit("abort"), [U(o), null];
  }
};
export {
  we as createRequestOperation
};
