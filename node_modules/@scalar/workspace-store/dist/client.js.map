{
  "version": 3,
  "sources": ["../src/client.ts"],
  "sourcesContent": ["import { measureAsync, measureSync } from '@scalar/helpers/testing/measure'\nimport { type LoaderPlugin, bundle } from '@scalar/json-magic/bundle'\nimport { fetchUrls } from '@scalar/json-magic/bundle/plugins/browser'\nimport { type Difference, apply, diff, merge } from '@scalar/json-magic/diff'\nimport { generateHash } from '@scalar/json-magic/helpers/generate-hash'\nimport { createMagicProxy, getRaw } from '@scalar/json-magic/magic-proxy'\nimport { upgrade } from '@scalar/openapi-upgrader'\nimport type { Record } from '@scalar/typebox'\nimport { Value } from '@scalar/typebox/value'\nimport type { PartialDeep, RequiredDeep } from 'type-fest'\nimport { reactive, toRaw } from 'vue'\nimport YAML from 'yaml'\n\nimport { applySelectiveUpdates } from '@/helpers/apply-selective-updates'\nimport { deepClone } from '@/helpers/deep-clone'\nimport { createDetectChangesProxy } from '@/helpers/detect-changes-proxy'\nimport { type UnknownObject, isObject, safeAssign } from '@/helpers/general'\nimport { getValueByPath } from '@/helpers/json-path-utils'\nimport { mergeObjects } from '@/helpers/merge-object'\nimport { createOverridesProxy, unpackOverridesProxy } from '@/helpers/overrides-proxy'\nimport { unpackProxyObject } from '@/helpers/unpack-proxy'\nimport { createNavigation } from '@/navigation'\nimport { externalValueResolver, loadingStatus, refsEverywhere, restoreOriginalRefs } from '@/plugins/bundler'\nimport { getServersFromDocument } from '@/preprocessing/server'\nimport { extensions } from '@/schemas/extensions'\nimport { type InMemoryWorkspace, InMemoryWorkspaceSchema } from '@/schemas/inmemory-workspace'\nimport { defaultReferenceConfig } from '@/schemas/reference-config'\nimport { coerceValue } from '@/schemas/typebox-coerce'\nimport {\n  OpenAPIDocumentSchema as OpenAPIDocumentSchemaStrict,\n  type OpenApiDocument,\n} from '@/schemas/v3.1/strict/openapi-document'\nimport type { Workspace, WorkspaceDocumentMeta, WorkspaceMeta } from '@/schemas/workspace'\nimport type { WorkspaceSpecification } from '@/schemas/workspace-specification'\nimport type { Config, DocumentConfiguration } from '@/schemas/workspace-specification/config'\nimport type { WorkspacePlugin, WorkspaceStateChangeEvent } from '@/workspace-plugin'\n\ntype ExtraDocumentConfigurations = Record<\n  string,\n  {\n    fetch: WorkspaceDocumentMetaInput['fetch']\n  }\n>\n\nconst defaultConfig: RequiredDeep<Config> = {\n  'x-scalar-reference-config': defaultReferenceConfig,\n}\n\n/**\n * Input type for workspace document metadata and configuration.\n * This type defines the required and optional fields for initializing a document in the workspace.\n */\ntype WorkspaceDocumentMetaInput = {\n  /** Optional metadata about the document like title, description, etc */\n  meta?: WorkspaceDocumentMeta\n  /** Required unique identifier for the document */\n  name: string\n  /** Optional configuration options */\n  config?: DocumentConfiguration\n  /** Overrides for the document */\n  overrides?: PartialDeep<OpenApiDocument>\n  /** Optional custom fetch implementation to use when retrieving the document. By default the global fetch implementation will be used */\n  fetch?: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response>\n}\n\n/**\n * Represents a document that is loaded from a URL.\n * This type extends WorkspaceDocumentMetaInput to include URL-specific properties.\n */\nexport type UrlDoc = {\n  /** URL to fetch the OpenAPI document from */\n  url: string\n} & WorkspaceDocumentMetaInput\n\n/** Represents a document that is provided directly as an object rather than loaded from a URL */\nexport type ObjectDoc = {\n  /** The OpenAPI document object containing the API specification */\n  document: Record<string, unknown>\n} & WorkspaceDocumentMetaInput\n\n/**\n * Union type representing the possible input formats for a workspace document:\n * - UrlDoc: Document loaded from a URL with optional fetch configuration\n * - ObjectDoc: Direct document object with metadata\n */\nexport type WorkspaceDocumentInput = UrlDoc | ObjectDoc\n\n/**\n * Resolves a workspace document from various input sources (URL, local file, or direct document object).\n *\n * @param workspaceDocument - The document input to resolve, which can be:\n *   - A URL to fetch the document from\n *   - A direct document object\n * @returns A promise that resolves to an object containing:\n *   - ok: boolean indicating if the resolution was successful\n *   - data: The resolved document data\n *\n * @example\n * // Resolve from URL\n * const urlDoc = await loadDocument({ name: 'api', url: 'https://api.example.com/openapi.json' })\n *\n * // Resolve direct document\n * const directDoc = await loadDocument({\n *   name: 'inline',\n *   document: { openapi: '3.0.0', paths: {} }\n * })\n */\nfunction loadDocument(workspaceDocument: WorkspaceDocumentInput): ReturnType<LoaderPlugin['exec']> {\n  if ('url' in workspaceDocument) {\n    return fetchUrls({ fetch: workspaceDocument.fetch }).exec(workspaceDocument.url)\n  }\n\n  return Promise.resolve({\n    ok: true,\n    data: workspaceDocument.document,\n    // string version of the raw document for hashing purposes\n    raw: JSON.stringify(workspaceDocument.document),\n  })\n}\n\n/**\n * Returns the origin (URL) of a workspace document if it was loaded from a URL.\n * If the document was provided directly as an object, returns undefined.\n *\n * @param input - The workspace document input (either UrlDoc or ObjectDoc)\n * @returns The URL string if present, otherwise undefined\n */\nconst getDocumentSource = (input: WorkspaceDocumentInput) => {\n  if ('url' in input) {\n    return input.url\n  }\n  return undefined\n}\n\n/**\n * Configuration object for initializing a workspace store.\n * Defines the initial state and documents for the workspace.\n */\ntype WorkspaceProps = {\n  /** Optional metadata for the workspace including theme, active document, etc */\n  meta?: WorkspaceMeta\n  /** Workspace configuration */\n  config?: PartialDeep<Config>\n  /** Fetch function for retrieving documents */\n  fetch?: WorkspaceDocumentInput['fetch']\n  /** A list of all registered plugins for the current workspace */\n  plugins?: WorkspacePlugin[]\n}\n\n/**\n * Type definition for the workspace store return object.\n * This explicit type is needed to avoid TypeScript inference limits.\n *\n * @see https://github.com/microsoft/TypeScript/issues/43817#issuecomment-827746462\n */\nexport type WorkspaceStore = {\n  /**\n   * Returns the reactive workspace object with an additional activeDocument getter\n   */\n  readonly workspace: Workspace\n  /**\n   * Updates a specific metadata field in the workspace\n   * @param key - The metadata field to update\n   * @param value - The new value for the field\n   * @example\n   * // Update the workspace title\n   * update('x-scalar-active-document', 'document-name')\n   */\n  update<K extends keyof WorkspaceMeta>(key: K, value: WorkspaceMeta[K]): void\n  /**\n   * Updates a specific metadata field in a document\n   * @param name - The name of the document to update ('active' or a specific document name)\n   * @param key - The metadata field to update\n   * @param value - The new value for the field\n   * @throws Error if the specified document doesn't exist\n   * @example\n   * // Update the auth of the active document\n   * updateDocument('active', 'x-scalar-active-auth', 'Bearer')\n   * // Update the auth of a specific document\n   * updateDocument('document-name', 'x-scalar-active-auth', 'Bearer')\n   */\n  updateDocument<K extends keyof WorkspaceDocumentMeta>(\n    name: 'active' | (string & {}),\n    key: K,\n    value: WorkspaceDocumentMeta[K],\n  ): void\n  /**\n   * Replaces the content of a specific document in the workspace with the provided input.\n   * This method computes the difference between the current document and the new input,\n   * then applies only the necessary changes in place. The updates are applied atomically,\n   * ensuring the document is updated in a single operation.\n   *\n   * @param documentName - The name of the document to update.\n   * @param input - The new content to apply to the document (as a plain object).\n   * @example\n   * // Replace the content of the 'api' document with new data\n   * store.replaceDocument('api', {\n   *   openapi: '3.1.0',\n   *   info: { title: 'Updated API', version: '1.0.1' },\n   *   paths: {},\n   * })\n   */\n  replaceDocument(documentName: string, input: Record<string, unknown>): Promise<void>\n  /**\n   * Resolves a reference in the active document by following the provided path and resolving any external $ref references.\n   * This method traverses the document structure following the given path and resolves any $ref references it encounters.\n   * During resolution, it sets a loading status and updates the reference with the resolved content.\n   *\n   * @param path - Array of strings representing the path to the reference (e.g. ['paths', '/users', 'get', 'responses', '200'])\n   * @throws Error if the path is invalid or empty\n   * @example\n   * // Resolve a reference in the active document\n   * resolve(['paths', '/users', 'get', 'responses', '200'])\n   */\n  resolve(path: string[]): Promise<unknown>\n  /**\n   * Adds a new document to the workspace\n   * @param document - The document content to add. This should be a valid OpenAPI/Swagger document or other supported format\n   * @param meta - Metadata for the document, including its name and other properties defined in WorkspaceDocumentMeta\n   * @example\n   * // Add a new OpenAPI document to the workspace\n   * store.addDocument({\n   *   name: 'name',\n   *   document: {\n   *     openapi: '3.0.0',\n   *     info: { title: 'title' },\n   *   },\n   *   meta: {\n   *     'x-scalar-active-auth': 'Bearer',\n   *     'x-scalar-active-server': 'production'\n   *   }\n   * })\n   */\n  addDocument(input: WorkspaceDocumentInput): Promise<void>\n  /**\n   * Returns the merged configuration for the active document.\n   *\n   * This getter merges configurations in the following order of precedence:\n   * 1. Document-specific configuration (highest priority)\n   * 2. Workspace-level configuration\n   * 3. Default configuration (lowest priority)\n   *\n   * The active document is determined by the workspace's activeDocument extension,\n   * falling back to the first document if none is specified.\n   */\n  readonly config: typeof defaultConfig\n  /**\n   * Exports the specified document in the requested format.\n   *\n   * This method serializes the most recently saved local version of the document (from the intermediateDocuments map)\n   * to either JSON or YAML. The exported document reflects the last locally saved state, including any edits\n   * that have been saved but not yet synced to a remote registry. Runtime/in-memory changes that have not been saved\n   * will not be included.\n   *\n   * @param documentName - The name of the document to export.\n   * @param format - The output format: 'json' for a JSON string, or 'yaml' for a YAML string.\n   * @returns The document as a string in the requested format, or undefined if the document does not exist.\n   *\n   * @example\n   * // Export a document as JSON\n   * const jsonString = store.exportDocument('api', 'json')\n   *\n   * // Export a document as YAML\n   * const yamlString = store.exportDocument('api', 'yaml')\n   */\n  exportDocument(documentName: string, format: 'json' | 'yaml', minify?: boolean): string | undefined\n  /**\n   * Exports the currently active document in the requested format.\n   *\n   * This is a convenience method that exports the active document (determined by the workspace's\n   * activeDocument extension) without requiring the caller to specify the document name.\n   * The exported document reflects the last locally saved state, including any edits that have\n   * been saved but not yet synced to a remote registry.\n   *\n   * @param format - The output format: 'json' for a JSON string, or 'yaml' for a YAML string.\n   * @returns The active document as a string in the requested format, or undefined if no active document exists.\n   *\n   * @example\n   * // Export the active document as JSON\n   * const jsonString = store.exportActiveDocument('json')\n   *\n   * // Export the active document as YAML\n   * const yamlString = store.exportActiveDocument('yaml')\n   */\n  exportActiveDocument(format: 'json' | 'yaml', minify?: boolean): string | undefined\n  /**\n   * Saves the current state of the specified document to the intermediate documents map.\n   *\n   * This function captures the latest (reactive) state of the document from the workspace and\n   * applies its changes to the corresponding entry in the `intermediateDocuments` map.\n   * The `intermediateDocuments` map represents the most recently \"saved\" local version of the document,\n   * which may include edits not yet synced to the remote registry.\n   *\n   * The update is performed in-place. A deep clone of the current document\n   * state is used to avoid mutating the reactive object directly.\n   *\n   * @param documentName - The name of the document to save.\n   * @returns An array of diffs that were excluded from being applied (such as changes to ignored keys),\n   *          or undefined if the document does not exist or cannot be updated.\n   *\n   * @example\n   * // Save the current state of the document named 'api'\n   * const excludedDiffs = store.saveDocument('api')\n   */\n  saveDocument(documentName: string): Promise<unknown[] | undefined>\n  /**\n   * Restores the specified document to its last locally saved state.\n   *\n   * This method updates the current reactive document (in the workspace) with the contents of the\n   * corresponding intermediate document (from the `intermediateDocuments` map), effectively discarding\n   * any unsaved in-memory changes and reverting to the last saved version.\n   * Vue reactivity is preserved by updating the existing reactive object in place.\n   *\n   * **Warning:** This operation will discard all unsaved (in-memory) changes to the specified document.\n   *\n   * @param documentName - The name of the document to restore.\n   * @returns void\n   *\n   * @example\n   * // Restore the document named 'api' to its last saved state\n   * store.revertDocumentChanges('api')\n   */\n  revertDocumentChanges(documentName: string): Promise<void>\n  /**\n   * Commits the specified document.\n   *\n   * This method is intended to finalize and persist the current state of the document,\n   * potentially syncing it with a remote registry or marking it as the latest committed version.\n   *\n   * @param documentName - The name of the document to commit.\n   * @remarks\n   * The actual commit logic is not implemented yet.\n   */\n  commitDocument(documentName: string): void\n  /**\n   * Exports the complete current workspace state as a plain JavaScript object.\n   *\n   * The returned object includes all workspace documents (with Vue reactivity removed), workspace metadata,\n   * document configurations, and both the original and intermediate document maps. This object can be\n   * serialized (e.g., with JSON.stringify) and later imported to fully restore the workspace\u2014including\n   * all documents, their configurations, metadata, and historical states.\n   *\n   * @returns An `InMemoryWorkspace` object representing the entire workspace state,\n   *          suitable for persistence, backup, or sharing.\n   */\n  exportWorkspace(): InMemoryWorkspace\n  /**\n   * Imports a workspace from a serialized JSON string.\n   *\n   * This method parses the input string using the InMemoryWorkspaceSchema,\n   * then updates the current workspace state, including documents, metadata,\n   * and configuration, with the imported values.\n   *\n   * @param input - The serialized workspace JSON string to import.\n   */\n  loadWorkspace(input: InMemoryWorkspace): void\n  /**\n   * Imports a workspace from a WorkspaceSpecification object.\n   *\n   * This method assigns workspace metadata and adds all documents defined in the specification.\n   * Each document is added using its $ref and optional overrides.\n   *\n   * @example\n   * ```ts\n   * await store.importWorkspaceFromSpecification({\n   *   documents: {\n   *     api: { $ref: '/specs/api.yaml' },\n   *     petstore: { $ref: '/specs/petstore.yaml' }\n   *   },\n   *   overrides: {\n   *     api: { config: { features: { showModels: true } } }\n   *   },\n   *   info: { title: 'My Workspace' },\n   *   workspace: 'v1',\n   *   \"x-scalar-dark-mode\": true\n   * })\n   * ```\n   *\n   * @param specification - The workspace specification to import.\n   */\n  importWorkspaceFromSpecification(specification: WorkspaceSpecification): Promise<void[]>\n  /**\n   * Rebases a document in the workspace by refetching its origin and merging with local edits.\n   *\n   * This method fetches the latest version of the document (optionally with custom fetch/config),\n   * calculates changes relative to the original and locally edited versions,\n   * and attempts to update the workspace document while preserving user edits.\n   * If automatic resolution isn't possible due to conflicts, returns a conflict list for the caller to resolve.\n   * If `resolvedConflicts` are provided (e.g., after user intervention), applies them to complete the rebase.\n   *\n   * @param input Object specifying which document to rebase\n   * @returns If there are unresolved conflicts, resolves to an object containing the list of conflicts and a method to apply user-resolved conflicts; otherwise resolves to void.\n   *\n   * @example\n   * // Rebase a document and handle conflicts interactively\n   * const result = await store.rebaseDocument({ name: 'api', fetch: customFetch });\n   * if (result && result.ok) {\n   *   // Present conflicts to the user and collect resolutions...\n   *   await result.applyChanges(userResolvedConflicts);\n   * }\n   */\n  rebaseDocument: (input: WorkspaceDocumentInput) => Promise<\n    | { ok: false; type: 'CORRUPTED_STATE' | 'FETCH_FAILED' | 'NO_CHANGES_DETECTED'; message: string }\n    | {\n        ok: true\n        conflicts: ReturnType<typeof merge>['conflicts']\n        applyChanges: (resolvedConflicts: Difference<unknown>[]) => Promise<void>\n      }\n  >\n}\n\n/**\n * Creates a reactive workspace store that manages documents and their metadata.\n * The store provides functionality for accessing, updating, and resolving document references.\n *\n * @param workspaceProps - Configuration object for the workspace\n * @param workspaceProps.meta - Optional metadata for the workspace\n * @param workspaceProps.documents - Optional record of documents to initialize the workspace with\n *  Documents that require asynchronous loading must be added using `addDocument` after the store is created\n *  this allows atomic awaiting and does not block page load for the store initialization\n * @returns An object containing methods and getters for managing the workspace\n */\nexport const createWorkspaceStore = (workspaceProps?: WorkspaceProps): WorkspaceStore => {\n  /**\n   * Holds additional configuration options for each document in the workspace.\n   *\n   * This can include settings that can not be persisted between sessions (not JSON serializable)\n   */\n  const extraDocumentConfigurations: ExtraDocumentConfigurations = {}\n\n  /**\n   * Notifies all workspace plugins of a workspace state change event.\n   *\n   * This function iterates through all registered plugins (if any) and invokes\n   * their onWorkspaceStateChanges hook with the given event object.\n   *\n   * @param event - The workspace state change event to broadcast to plugins\n   */\n  const fireWorkspaceChange = (event: WorkspaceStateChangeEvent) => {\n    workspaceProps?.plugins?.forEach((plugin) => plugin.hooks?.onWorkspaceStateChanges?.(event))\n  }\n\n  /**\n   * An object containing the reactive workspace state.\n   *\n   * Every change to the workspace, is tracked and broadcast to all registered plugins.\n   * allowing for change tracking.\n   *\n   * NOTE:\n   * The detect changes proxy is applied separately beacause the vue reactitvity proxy have to be the outer most proxy.\n   * If the order is reversed, Vue cannot properly track mutations, leading to lost reactivity and bugs.\n   * By wrapping the contents with the detect changes proxy first, and then passing the result to Vue's `reactive`,\n   * we ensure that Vue manages its reactivity as expected and our change detection hooks\n   * are also triggered reliably.\n   * Do not reverse this order\u203C\uFE0F\n   */\n  const workspace = reactive<Workspace>(\n    createDetectChangesProxy(\n      {\n        ...workspaceProps?.meta,\n        documents: {},\n        /**\n         * Returns the currently active document from the workspace.\n         * The active document is determined by the 'x-scalar-active-document' metadata field,\n         * falling back to the first document in the workspace if no active document is specified.\n         *\n         * @returns The active document or undefined if no document is found\n         */\n        get activeDocument(): NonNullable<Workspace['activeDocument']> | undefined {\n          return workspace.documents[getActiveDocumentName()]\n        },\n      },\n      {\n        hooks: {\n          onAfterChange(path) {\n            const type = path[0]\n\n            /** Document changes */\n            if (type === 'documents') {\n              // We are overriding the while documents object, ignore. This should not happen\n              if (path.length < 2) {\n                console.log('[WARN]: Overriding entire documents object is not supported')\n                return\n              }\n\n              const documentName = path[1] as string\n              const event = {\n                type: 'documents',\n                documentName,\n                value: unpackProxyObject(\n                  workspace.documents[documentName] ?? {\n                    openapi: '3.1.0',\n                    info: { title: '', version: '' },\n                    'x-scalar-original-document-hash': '',\n                  },\n                ),\n              } satisfies WorkspaceStateChangeEvent\n\n              fireWorkspaceChange(event)\n              return\n            }\n\n            /** Active document changes */\n            if (type === 'activeDocument') {\n              const documentName = getActiveDocumentName()\n              // Active document changed\n              const event = {\n                type: 'documents',\n                documentName,\n                value: unpackProxyObject(\n                  workspace.documents[documentName] ?? {\n                    openapi: '3.1.0',\n                    info: { title: '', version: '' },\n                    'x-scalar-original-document-hash': '',\n                  },\n                ),\n              } satisfies WorkspaceStateChangeEvent\n\n              fireWorkspaceChange(event)\n              return\n            }\n\n            /** Document meta changes */\n            const { activeDocument: _a, documents: _d, ...meta } = workspace\n            const event = {\n              type: 'meta',\n              value: unpackProxyObject(meta),\n            } satisfies WorkspaceStateChangeEvent\n\n            fireWorkspaceChange(event)\n            return\n          },\n        },\n      },\n    ),\n  )\n\n  /**\n   * An object containing all the workspace state, wrapped in a detect changes proxy.\n   *\n   * Every change to the workspace state (documents, configs, metadata, etc.) can be detected here,\n   * allowing for change tracking.\n   */\n  const { originalDocuments, intermediateDocuments, overrides, documentConfigs } = createDetectChangesProxy(\n    {\n      /**\n       * Holds the original, unmodified documents as they were initially loaded into the workspace.\n       * These documents are stored in their raw form\u2014prior to any reactive wrapping, dereferencing, or bundling.\n       * This map preserves the pristine structure of each document, using deep clones to ensure that\n       * subsequent mutations in the workspace do not affect the originals.\n       * The originals are retained so that we can restore, compare, or sync with the remote registry as needed.\n       */\n      originalDocuments: {} as Record<string, UnknownObject>,\n      /**\n       * Stores the intermediate state of documents after local edits but before syncing with the remote registry.\n       *\n       * This map acts as a local \"saved\" version of the document, reflecting the user's changes after they hit \"save\".\n       * The `originalDocuments` map, by contrast, always mirrors the document as it exists in the remote registry.\n       *\n       * Use this map to stage local changes that are ready to be propagated back to the remote registry.\n       * This separation allows us to distinguish between:\n       *   - The last known remote version (`originalDocuments`)\n       *   - The latest locally saved version (`intermediateDocuments`)\n       *   - The current in-memory (possibly unsaved) workspace document (`workspace.documents`)\n       */\n      intermediateDocuments: {} as Record<string, UnknownObject>,\n      /**\n       * A map of document configurations keyed by document name.\n       * This stores the configuration options for each document in the workspace,\n       * allowing for document-specific settings like navigation options, appearance,\n       * and other reference configuration.\n       */\n      documentConfigs: {} as Record<string, Config>,\n      /**\n       * Stores per-document overrides for OpenAPI documents.\n       * This object is used to override specific fields of a document\n       * when you cannot (or should not) modify the source document directly.\n       * For example, this enables UI-driven or temporary changes to be applied\n       * on top of the original document, without mutating the source.\n       * The key is the document name, and the value is a deep partial\n       * OpenAPI document representing the overridden fields.\n       */\n      overrides: {} as InMemoryWorkspace['overrides'],\n    },\n    {\n      hooks: {\n        onAfterChange(path) {\n          const type = path[0]\n\n          if (!type) {\n            return\n          }\n\n          if (path.length < 2) {\n            return\n          }\n\n          const documentName = path[1] as string\n          if (type === 'originalDocuments') {\n            const event = {\n              type,\n              documentName: documentName,\n              value: unpackProxyObject(originalDocuments[documentName] ?? {}),\n            } satisfies WorkspaceStateChangeEvent\n            fireWorkspaceChange(event)\n          }\n\n          if (type === 'intermediateDocuments') {\n            const event = {\n              type,\n              documentName: documentName,\n              value: unpackProxyObject(intermediateDocuments[documentName] ?? {}),\n            } satisfies WorkspaceStateChangeEvent\n            fireWorkspaceChange(event)\n          }\n\n          if (type === 'documentConfigs') {\n            const event = {\n              type,\n              documentName: documentName,\n              value: unpackProxyObject(documentConfigs[documentName] ?? {}),\n            } satisfies WorkspaceStateChangeEvent\n            fireWorkspaceChange(event)\n          }\n\n          if (type === 'overrides') {\n            const event = {\n              type,\n              documentName: documentName,\n              value: unpackProxyObject(overrides[documentName] ?? {}),\n            } satisfies WorkspaceStateChangeEvent\n            fireWorkspaceChange(event)\n          }\n        },\n      },\n    },\n  )\n\n  /**\n   * Returns the name of the currently active document in the workspace.\n   * The active document is determined by the 'x-scalar-active-document' metadata field,\n   * falling back to the first document in the workspace if no active document is specified.\n   *\n   * @returns The name of the active document or an empty string if no document is found\n   */\n  function getActiveDocumentName() {\n    return workspace[extensions.workspace.activeDocument] ?? Object.keys(workspace.documents)[0] ?? ''\n  }\n\n  function exportDocument(documentName: string, format: 'json' | 'yaml', minify?: boolean) {\n    const intermediateDocument = intermediateDocuments[documentName]\n\n    if (!intermediateDocument) {\n      return\n    }\n\n    if (format === 'json') {\n      return minify ? JSON.stringify(intermediateDocument) : JSON.stringify(intermediateDocument, null, 2)\n    }\n\n    return YAML.stringify(intermediateDocument)\n  }\n\n  // Save the current state of the specified document to the intermediate documents map.\n  // This function captures the latest (reactive) state of the document from the workspace and\n  // applies its changes to the corresponding entry in the `intermediateDocuments` map.\n  // The `intermediateDocuments` map represents the most recently \"saved\" local version of the document,\n  // which may include edits not yet synced to the remote registry.\n  async function saveDocument(documentName: string) {\n    const intermediateDocument = intermediateDocuments[documentName]\n    const workspaceDocument = workspace.documents[documentName]\n\n    if (!workspaceDocument) {\n      return\n    }\n\n    // Obtain the raw state of the current document to ensure accurate diffing\n    const updatedDocument = getRaw(workspaceDocument)\n\n    // If either the intermediate or updated document is missing, do nothing\n    if (!intermediateDocument || !updatedDocument) {\n      return\n    }\n\n    // Traverse the document and convert refs back to the original shape\n    const updatedWithOriginalRefs = await bundle(deepClone(updatedDocument), {\n      plugins: [restoreOriginalRefs()],\n      treeShake: false,\n      urlMap: true,\n    })\n\n    // Apply changes from the current document to the intermediate document in place\n    const excludedDiffs = applySelectiveUpdates(intermediateDocument, updatedWithOriginalRefs as UnknownObject)\n    return excludedDiffs\n  }\n\n  const processDocument = (input: OpenApiDocument, options: Config & { documentSource?: string }): OpenApiDocument => {\n    // Get the servers from the document or the config and perform some mutations on them\n    const servers = getServersFromDocument(options['x-scalar-reference-config']?.settings?.servers ?? input.servers, {\n      baseServerUrl: options['x-scalar-reference-config']?.settings?.baseServerUrl,\n      documentUrl: options.documentSource,\n    })\n\n    if (servers.length) {\n      input.servers = servers.map((it) => ({ url: it.url, description: it.description, variables: it.variables }))\n    }\n\n    return input\n  }\n\n  // Add a document to the store synchronously from an in-memory OpenAPI document\n  async function addInMemoryDocument(\n    input: ObjectDoc & { initialize?: boolean; documentSource?: string; documentHash: string },\n  ) {\n    const { name, meta } = input\n    const clonedRawInputDocument = measureSync('deepClone', () => deepClone(input.document))\n\n    measureSync('initialize', () => {\n      if (input.initialize !== false) {\n        // Store the original document in the originalDocuments map\n        // This is used to track the original state of the document as it was loaded into the workspace\n        originalDocuments[name] = deepClone(clonedRawInputDocument)\n\n        // Store the intermediate document state for local edits\n        // This is used to track the last saved state of the document\n        // It allows us to differentiate between the original document and the latest saved version\n        // This is important for local edits that are not yet synced with the remote registry\n        // The intermediate document is used to store the latest saved state of the document\n        // This allows us to track changes and revert to the last saved state if needed\n        intermediateDocuments[name] = deepClone(clonedRawInputDocument)\n        // Add the document config to the documentConfigs map\n        documentConfigs[name] = input.config ?? {}\n        // Store the overrides for this document, or an empty object if none are provided\n        overrides[name] = input.overrides ?? {}\n        // Store extra document configurations that can not be persisted\n        extraDocumentConfigurations[name] = { fetch: input.fetch }\n      }\n    })\n\n    const inputDocument = measureSync('upgrade', () => upgrade(deepClone(clonedRawInputDocument), '3.1'))\n\n    const strictDocument: UnknownObject = createMagicProxy(\n      {\n        ...inputDocument,\n        ...meta,\n        'x-original-oas-version': originalDocuments[name]?.openapi ?? originalDocuments[name]?.swagger,\n        'x-scalar-original-document-hash': input.documentHash,\n        'x-scalar-original-source-url': input.documentSource,\n      },\n      { showInternal: true },\n    )\n\n    if (strictDocument[extensions.document.navigation] === undefined) {\n      // If the document navigation is not already present, bundle the entire document to resolve all references.\n      // This typically applies when the document is not preprocessed by the server and needs local reference resolution.\n      // We need to bundle document first before we validate, so we can also validate the external references\n      await measureAsync(\n        'bundle',\n        async () =>\n          await bundle(getRaw(strictDocument), {\n            treeShake: false,\n            plugins: [\n              fetchUrls({\n                fetch: extraDocumentConfigurations[name]?.fetch ?? workspaceProps?.fetch,\n              }),\n              externalValueResolver(),\n              refsEverywhere(),\n            ],\n            urlMap: true,\n            origin: input.documentSource, // use the document origin (if provided) as the base URL for resolution\n          }),\n      )\n\n      // We coerce the values only when the document is not preprocessed by the server-side-store\n      const coerced = measureSync('coerceValue', () =>\n        coerceValue(OpenAPIDocumentSchemaStrict, deepClone(strictDocument)),\n      )\n      measureSync('mergeObjects', () => mergeObjects(strictDocument, coerced))\n    }\n\n    const isValid = Value.Check(OpenAPIDocumentSchemaStrict, strictDocument)\n\n    if (!isValid) {\n      const validationErrors = Array.from(Value.Errors(OpenAPIDocumentSchemaStrict, strictDocument))\n\n      console.warn('document validation errors: ')\n      console.warn(\n        validationErrors.map((error) => ({\n          message: error.message,\n          path: error.path,\n          schema: error.schema,\n          value: error.value,\n        })),\n      )\n    }\n\n    // Skip navigation generation if the document already has a server-side generated navigation structure\n    if (strictDocument[extensions.document.navigation] === undefined) {\n      const navigation = createNavigation(name, strictDocument as OpenApiDocument, input.config)\n\n      strictDocument[extensions.document.navigation] = navigation\n\n      // Do some document processing\n      processDocument(getRaw(strictDocument as OpenApiDocument), {\n        ...(documentConfigs[name] ?? {}),\n        documentSource: input.documentSource,\n      })\n    }\n\n    // Create a proxied document with magic proxy and apply any overrides, then store it in the workspace documents map\n    // We create a new proxy here in order to hide internal properties after validation and processing\n    // This ensures that the workspace document only exposes the intended OpenAPI properties and extensions\n    workspace.documents[name] = createOverridesProxy(createMagicProxy(getRaw(strictDocument)) as OpenApiDocument, {\n      overrides: overrides[name],\n    })\n  }\n\n  // Asynchronously adds a new document to the workspace by loading and validating the input.\n  // If loading fails, a placeholder error document is added instead.\n  async function addDocument(input: WorkspaceDocumentInput) {\n    const { name, meta } = input\n\n    const resolve = await measureAsync(\n      'loadDocument',\n      async () => await loadDocument({ ...input, fetch: input.fetch ?? workspaceProps?.fetch }),\n    )\n\n    // Log the time taken to add a document\n    await measureAsync('addDocument', async () => {\n      if (!resolve.ok) {\n        console.error(`Failed to fetch document '${name}': request was not successful`)\n\n        workspace.documents[name] = {\n          ...meta,\n          openapi: '3.1.0',\n          info: {\n            title: `Document '${name}' could not be loaded`,\n            version: 'unknown',\n          },\n          'x-scalar-original-document-hash': 'not-a-hash',\n        }\n\n        return\n      }\n\n      if (!isObject(resolve.data)) {\n        console.error(`Failed to load document '${name}': response data is not a valid object`)\n\n        workspace.documents[name] = {\n          ...meta,\n          openapi: '3.1.0',\n          info: {\n            title: `Document '${name}' could not be loaded`,\n            version: 'unknown',\n          },\n          'x-scalar-original-document-hash': 'not-a-hash',\n        }\n\n        return\n      }\n\n      await addInMemoryDocument({\n        ...input,\n        document: resolve.data,\n        documentSource: getDocumentSource(input),\n        documentHash: await generateHash(resolve.raw),\n      })\n    })\n  }\n\n  // Returns the effective document configuration for a given document name,\n  // merging (in order of increasing priority): the default config, workspace-level config, and document-specific config.\n  const getDocumentConfiguration = (name: string) => {\n    return mergeObjects<typeof defaultConfig>(\n      mergeObjects(deepClone(defaultConfig), workspaceProps?.config ?? {}),\n      documentConfigs[name] ?? {},\n    )\n  }\n\n  // Cache to track visited nodes during reference resolution to prevent bundling the same subtree multiple times\n  // This is needed because we are doing partial bundle operations\n  const visitedNodesCache = new Set()\n\n  return {\n    get workspace() {\n      return workspace\n    },\n    update<K extends keyof WorkspaceMeta>(key: K, value: WorkspaceMeta[K]) {\n      // @ts-expect-error\n      if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n        throw new Error('Invalid key: cannot modify prototype')\n      }\n      Object.assign(workspace, { [key]: value })\n    },\n    updateDocument<K extends keyof WorkspaceDocumentMeta>(\n      name: 'active' | (string & {}),\n      key: K,\n      value: WorkspaceDocumentMeta[K],\n    ) {\n      const currentDocument = workspace.documents[name === 'active' ? getActiveDocumentName() : name]\n\n      if (!currentDocument) {\n        throw 'Please select a valid document'\n      }\n\n      Object.assign(currentDocument, { [key]: value })\n    },\n    async replaceDocument(documentName: string, input: Record<string, unknown>) {\n      const currentDocument = workspace.documents[documentName]\n\n      if (!currentDocument) {\n        return console.error(`Document '${documentName}' does not exist in the workspace.`)\n      }\n\n      // Replace the whole document\n      await addInMemoryDocument({\n        name: documentName,\n        document: input,\n        // Preserve the current metadata\n        documentSource: currentDocument['x-scalar-original-source-url'],\n        documentHash: currentDocument['x-scalar-original-document-hash'],\n        meta: {\n          'x-scalar-active-auth': currentDocument['x-scalar-active-auth'],\n          'x-scalar-active-server': currentDocument['x-scalar-active-server'],\n        },\n        initialize: false,\n      })\n    },\n    resolve: (path) => {\n      const activeDocument = workspace.activeDocument\n\n      const target = getValueByPath(activeDocument, path)\n\n      if (!isObject(target)) {\n        console.error(\n          `Invalid path provided for resolution. Path: [${path.join(', ')}]. Found value of type: ${typeof target}. Expected an object.`,\n        )\n        return Promise.resolve()\n      }\n\n      // Bundle the target document with the active document as root, resolving any external references\n      // and tracking resolution status through hooks\n      return bundle(target, {\n        root: activeDocument,\n        treeShake: false,\n        plugins: [fetchUrls(), loadingStatus(), externalValueResolver()],\n        urlMap: true,\n        visitedNodes: visitedNodesCache,\n      })\n    },\n    addDocument,\n    get config() {\n      return getDocumentConfiguration(getActiveDocumentName())\n    },\n    exportDocument,\n    exportActiveDocument: (format, minify) => exportDocument(getActiveDocumentName(), format, minify),\n    saveDocument,\n    async revertDocumentChanges(documentName: string) {\n      const workspaceDocument = workspace.documents[documentName]\n      const intermediate = intermediateDocuments[documentName]\n\n      if (!workspaceDocument || !intermediate) {\n        return\n      }\n\n      await addInMemoryDocument({\n        name: documentName,\n        document: intermediate,\n        documentSource: workspaceDocument['x-scalar-original-source-url'],\n        documentHash: workspaceDocument['x-scalar-original-document-hash'],\n        initialize: false,\n      })\n    },\n    commitDocument(documentName: string) {\n      // TODO: Implement commit logic\n      console.warn(`Commit operation for document '${documentName}' is not implemented yet.`)\n    },\n    exportWorkspace() {\n      return {\n        documents: {\n          ...Object.fromEntries(\n            Object.entries(workspace.documents).map(([name, doc]) => [\n              name,\n              // Extract the raw document data for export, removing any Vue reactivity wrappers.\n              // When importing, the document can be wrapped again in a magic proxy.\n              toRaw(getRaw(unpackOverridesProxy(doc))),\n            ]),\n          ),\n        },\n        meta: workspaceProps?.meta ?? {},\n        documentConfigs,\n        originalDocuments,\n        intermediateDocuments,\n        overrides,\n      } satisfies InMemoryWorkspace\n    },\n    loadWorkspace(input: InMemoryWorkspace) {\n      const result = coerceValue(InMemoryWorkspaceSchema, input)\n\n      // Assign the magic proxy to the documents\n      safeAssign(\n        workspace.documents,\n        Object.fromEntries(\n          Object.entries(result.documents).map(([name, doc]) => [\n            name,\n            createOverridesProxy(createMagicProxy(doc), {\n              overrides: result.overrides[name],\n            }),\n          ]),\n        ),\n      )\n\n      safeAssign(originalDocuments, result.originalDocuments)\n      safeAssign(intermediateDocuments, result.intermediateDocuments)\n      safeAssign(documentConfigs, result.documentConfigs as Record<string, Config>)\n      safeAssign(overrides, result.overrides)\n      safeAssign(workspace, result.meta)\n    },\n    importWorkspaceFromSpecification: (specification: WorkspaceSpecification) => {\n      const { documents, overrides, info: _info, workspace: _workspaceVersion, ...meta } = specification\n\n      // Assign workspace metadata\n      safeAssign(workspace, meta)\n\n      // Add workspace documents\n      return Promise.all(\n        Object.entries(documents ?? {}).map(([name, doc]) =>\n          addDocument({ url: doc.$ref, name, overrides: overrides?.[name] }),\n        ),\n      )\n    },\n    rebaseDocument: async (input: WorkspaceDocumentInput) => {\n      const { name } = input\n\n      // ---- Get the current documents\n      const originalDocument = originalDocuments[name]\n      const intermediateDocument = intermediateDocuments[name]\n      // raw version without any proxies\n      const activeDocument = workspace.documents[name]\n        ? toRaw(getRaw(unpackOverridesProxy(workspace.documents[name])))\n        : undefined\n\n      if (!originalDocument || !intermediateDocument || !activeDocument) {\n        // If any required document state is missing, do nothing\n        return {\n          ok: false,\n          type: 'CORRUPTED_STATE' as const,\n          message: `Cannot rebase document '${name}': missing original, intermediate, or active document state`,\n        }\n      }\n\n      // ---- Resolve input document\n      const resolve = await measureAsync(\n        'loadDocument',\n        async () => await loadDocument({ ...input, fetch: input.fetch ?? workspaceProps?.fetch }),\n      )\n\n      if (!resolve.ok || !isObject(resolve.data)) {\n        return {\n          ok: false,\n          type: 'FETCH_FAILED' as const,\n          message: `Failed to fetch document '${name}': request was not successful or returned invalid data`,\n        }\n      }\n\n      // Compare document hashes to see if the document has changed\n      // When the hashes match, we can skip the rebase process\n      const newHash = await generateHash(resolve.raw)\n      if (activeDocument['x-scalar-original-document-hash'] === newHash) {\n        return {\n          ok: false,\n          type: 'NO_CHANGES_DETECTED' as const,\n          message: `No changes detected for document '${name}': document hash matches the active document`,\n        }\n      }\n\n      const newDocumentOrigin = resolve.data\n\n      // ---- Override the configurations and metadata\n      documentConfigs[name] = input.config ?? {}\n      overrides[name] = input.overrides ?? {}\n      extraDocumentConfigurations[name] = { fetch: input.fetch }\n\n      // ---- Get the new intermediate document\n      const changelogAA = diff(originalDocument, newDocumentOrigin)\n\n      // When there are no changes, we can return early since we don't need to do anything\n      // This is not supposed to happen due to the hash check above, but just in case\n      if (changelogAA.length === 0) {\n        return {\n          ok: false,\n          type: 'NO_CHANGES_DETECTED' as const,\n          message: `No changes detected for document '${name}' after fetching the latest version.`,\n        }\n      }\n\n      const changelogAB = diff(originalDocument, intermediateDocument)\n\n      const changesA = merge(changelogAA, changelogAB)\n\n      return {\n        ok: true,\n        conflicts: changesA.conflicts,\n        applyChanges: async (resolvedConflicts: Difference<unknown>[]) => {\n          const changesetA = changesA.diffs.concat(resolvedConflicts)\n\n          // Apply the changes to the original document to get the new intermediate\n          const newIntermediateDocument = apply(deepClone(originalDocument), changesetA)\n          intermediateDocuments[name] = newIntermediateDocument\n\n          // Update the original document\n          originalDocuments[name] = newDocumentOrigin\n\n          // ---- Get the new active document\n          const changelogBA = diff(intermediateDocument, newIntermediateDocument)\n          const changelogBB = diff(intermediateDocument, activeDocument)\n\n          const changesB = merge(changelogBA, changelogBB)\n\n          // Auto-conflict resolution: pick only the changes from the first changeset\n          // TODO: In the future, implement smarter conflict resolution if needed\n          const changesetB = changesB.diffs.concat(changesB.conflicts.flatMap((it) => it[0]))\n\n          const newActiveDocument = coerceValue(\n            OpenAPIDocumentSchemaStrict,\n            apply(deepClone(newIntermediateDocument), changesetB),\n          )\n\n          // add the new active document to the workspace but don't re-initialize\n          await addInMemoryDocument({\n            ...input,\n            document: {\n              ...newActiveDocument,\n              // force regeneration of navigation\n              // when we are rebasing, we want to ensure that the navigation is always up to date\n              [extensions.document.navigation]: undefined,\n            },\n            documentSource: getDocumentSource(input),\n            // Update the original document hash\n            documentHash: await generateHash(resolve.raw),\n            initialize: false,\n          })\n        },\n      }\n    },\n  }\n}\n\n// biome-ignore lint/performance/noBarrelFile: It's a package entry point\nexport { generateClientMutators } from '@/mutators'\n"],
  "mappings": "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",
  "names": ["event", "overrides"]
}
