import { Type } from "@scalar/typebox";
import { createIndexDbConnection } from "../persistence/indexdb.js";
const createWorkspaceStorePersistence = async () => {
  const connection = await createIndexDbConnection({
    name: "scalar-workspace-store",
    version: 1,
    tables: {
      workspace: {
        schema: Type.Object({ id: Type.String(), name: Type.String() }),
        index: ["id"]
      },
      meta: {
        schema: Type.Object({ workspaceId: Type.String(), data: Type.Any() }),
        index: ["workspaceId"]
      },
      documents: {
        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),
        index: ["workspaceId", "documentName"]
      },
      originalDocuments: {
        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),
        index: ["workspaceId", "documentName"]
      },
      intermediateDocuments: {
        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),
        index: ["workspaceId", "documentName"]
      },
      overrides: {
        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),
        index: ["workspaceId", "documentName"]
      },
      documentConfigs: {
        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),
        index: ["workspaceId", "documentName"]
      }
    }
  });
  const workspaceTable = connection.get("workspace");
  const metaTable = connection.get("meta");
  const documentsTable = connection.get("documents");
  const originalDocumentTable = connection.get("originalDocuments");
  const intermediateDocumentTable = connection.get("intermediateDocuments");
  const overridesTable = connection.get("overrides");
  const documentConfigsTable = connection.get("documentConfigs");
  return {
    close: () => {
      connection.closeDatabase();
    },
    meta: {
      /**
       * Set meta data for a workspace.
       */
      setItem: async (workspaceId, data) => {
        await metaTable.addItem({ workspaceId }, { data });
      }
    },
    documents: {
      /**
       * Set (persist) a workspace document using workspaceId and documentName as composite key.
       */
      setItem: async (workspaceId, documentName, data) => {
        await documentsTable.addItem({ workspaceId, documentName }, { data });
      }
    },
    originalDocuments: {
      /**
       * Set an original (raw) document for a workspace/document pair.
       */
      setItem: async (workspaceId, documentName, data) => {
        await originalDocumentTable.addItem({ workspaceId, documentName }, { data });
      }
    },
    intermediateDocuments: {
      /**
       * Set an intermediate (transformed) document for a workspace/document pair.
       */
      setItem: async (workspaceId, documentName, data) => {
        await intermediateDocumentTable.addItem({ workspaceId, documentName }, { data });
      }
    },
    overrides: {
      /**
       * Set document overrides for a workspace/document pair.
       */
      setItem: async (workspaceId, documentName, data) => {
        await overridesTable.addItem({ workspaceId, documentName }, { data });
      }
    },
    documentConfigs: {
      /**
       * Set configuration for a document in a workspace.
       */
      setItem: async (workspaceId, documentName, data) => {
        await documentConfigsTable.addItem({ workspaceId, documentName }, { data });
      }
    },
    workspace: {
      /**
       * Retrieves a workspace by its ID.
       * Returns undefined if the workspace does not exist.
       * Gathers all workspace 'chunk' tables and assembles a full workspace shape.
       */
      getItem: async (id) => {
        const workspace = await workspaceTable.getItem({ id });
        if (!workspace) {
          return void 0;
        }
        const workspaceDocuments = await documentsTable.getRange([id]);
        const workspaceOriginalDocuments = await originalDocumentTable.getRange([id]);
        const workspaceIntermediateDocuments = await intermediateDocumentTable.getRange([id]);
        const workspaceOverrides = await overridesTable.getRange([id]);
        const workspaceMeta = await metaTable.getItem({ workspaceId: id });
        const workspaceDocumentConfigs = await documentConfigsTable.getRange([id]);
        return {
          id,
          name: workspace.name,
          workspace: {
            documents: Object.fromEntries(workspaceDocuments.map((item) => [item.documentName, item.data])),
            originalDocuments: Object.fromEntries(
              workspaceOriginalDocuments.map((item) => [item.documentName, item.data])
            ),
            intermediateDocuments: Object.fromEntries(
              workspaceIntermediateDocuments.map((item) => [item.documentName, item.data])
            ),
            overrides: Object.fromEntries(workspaceOverrides.map((item) => [item.documentName, item.data])),
            meta: workspaceMeta?.data,
            documentConfigs: Object.fromEntries(workspaceDocumentConfigs.map((item) => [item.documentName, item.data]))
          }
        };
      },
      /**
       * Retrieves all workspaces from the database.
       * Returns only the workspace ID and name for each workspace.
       * To get the full workspace data including documents and metadata, use getItem() with a specific ID.
       * Returns an empty array if no workspaces exist.
       */
      getAll: async () => {
        return await workspaceTable.getAll();
      },
      /**
       * Saves a workspace to the database.
       * All chunks (meta, documents, configs, etc.) are upsert in their respective tables.
       * If a workspace with the same ID already exists, it will be replaced.
       */
      setItem: async (id, value) => {
        await workspaceTable.addItem({ id }, { name: value.name });
        await metaTable.addItem({ workspaceId: id }, { data: value.workspace.meta });
        await Promise.all(
          Object.entries(value.workspace.documents ?? {}).map(([name, data]) => {
            return documentsTable.addItem({ workspaceId: id, documentName: name }, { data });
          })
        );
        await Promise.all(
          Object.entries(value.workspace.originalDocuments ?? {}).map(([name, data]) => {
            return originalDocumentTable.addItem({ workspaceId: id, documentName: name }, { data });
          })
        );
        await Promise.all(
          Object.entries(value.workspace.intermediateDocuments ?? {}).map(([name, data]) => {
            return intermediateDocumentTable.addItem({ workspaceId: id, documentName: name }, { data });
          })
        );
        await Promise.all(
          Object.entries(value.workspace.overrides ?? {}).map(([name, data]) => {
            return overridesTable.addItem({ workspaceId: id, documentName: name }, { data });
          })
        );
        await Promise.all(
          Object.entries(value.workspace.documentConfigs ?? {}).map(([name, data]) => {
            return documentConfigsTable.addItem({ workspaceId: id, documentName: name }, { data });
          })
        );
      },
      /**
       * Deletes an entire workspace and all associated chunk records from all tables by ID.
       */
      deleteItem: async (id) => {
        await workspaceTable.deleteItem({ id });
        await Promise.all([
          // By id
          metaTable.deleteItem({ workspaceId: id }),
          // By range (composite-key tables)
          documentsTable.deleteRange([id]),
          originalDocumentTable.deleteRange([id]),
          intermediateDocumentTable.deleteRange([id]),
          overridesTable.deleteRange([id]),
          documentConfigsTable.deleteRange([id])
        ]);
      }
    }
  };
};
export {
  createWorkspaceStorePersistence
};
//# sourceMappingURL=index.js.map
