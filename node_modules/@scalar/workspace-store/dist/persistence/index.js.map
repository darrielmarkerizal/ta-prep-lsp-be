{
  "version": 3,
  "sources": ["../../src/persistence/index.ts"],
  "sourcesContent": ["import { Type } from '@scalar/typebox'\n\nimport { createIndexDbConnection } from '@/persistence/indexdb'\nimport type { InMemoryWorkspace } from '@/schemas/inmemory-workspace'\nimport type { WorkspaceMeta } from '@/schemas/workspace'\n\ntype WorkspaceStoreShape = {\n  name: string\n  workspace: InMemoryWorkspace\n}\n\n/**\n * Creates the persistence layer for the workspace store using IndexedDB.\n * This sets up all the required tables for storing workspace chunk information,\n * such as workspace meta, documents, original documents, intermediate documents, overrides, etc.\n * Each logical group (meta, documents, etc) gets its own table keyed appropriately for efficient sub-document access.\n * Returns an object containing `meta`, `documents`, `originalDocuments`, `intermediateDocuments`, `overrides`,\n * `documentMeta`, `documentConfigs`, and `workspace` sections, each exposing a `setItem` method\n * for upsetting records, and in the case of `workspace`, also `getItem` and `deleteItem`.\n */\nexport const createWorkspaceStorePersistence = async () => {\n  // Create the database connection and setup all required tables for workspace storage.\n  const connection = await createIndexDbConnection({\n    name: 'scalar-workspace-store',\n    version: 1,\n    tables: {\n      workspace: {\n        schema: Type.Object({ id: Type.String(), name: Type.String() }),\n        index: ['id'],\n      },\n      meta: {\n        schema: Type.Object({ workspaceId: Type.String(), data: Type.Any() }),\n        index: ['workspaceId'],\n      },\n      documents: {\n        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),\n        index: ['workspaceId', 'documentName'],\n      },\n      originalDocuments: {\n        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),\n        index: ['workspaceId', 'documentName'],\n      },\n      intermediateDocuments: {\n        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),\n        index: ['workspaceId', 'documentName'],\n      },\n      overrides: {\n        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),\n        index: ['workspaceId', 'documentName'],\n      },\n      documentConfigs: {\n        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),\n        index: ['workspaceId', 'documentName'],\n      },\n    },\n  })\n\n  // Tables wrappers for each logical section.\n  const workspaceTable = connection.get('workspace')\n  const metaTable = connection.get('meta')\n  const documentsTable = connection.get('documents')\n  const originalDocumentTable = connection.get('originalDocuments')\n  const intermediateDocumentTable = connection.get('intermediateDocuments')\n  const overridesTable = connection.get('overrides')\n  const documentConfigsTable = connection.get('documentConfigs')\n\n  // The returned persistence API with logical sections for each table and mapping.\n  return {\n    close: () => {\n      connection.closeDatabase()\n    },\n    meta: {\n      /**\n       * Set meta data for a workspace.\n       */\n      setItem: async (workspaceId: string, data: WorkspaceMeta) => {\n        await metaTable.addItem({ workspaceId }, { data })\n      },\n    },\n    documents: {\n      /**\n       * Set (persist) a workspace document using workspaceId and documentName as composite key.\n       */\n      setItem: async (workspaceId: string, documentName: string, data: InMemoryWorkspace['documents'][string]) => {\n        await documentsTable.addItem({ workspaceId, documentName }, { data })\n      },\n    },\n    originalDocuments: {\n      /**\n       * Set an original (raw) document for a workspace/document pair.\n       */\n      setItem: async (\n        workspaceId: string,\n        documentName: string,\n        data: InMemoryWorkspace['originalDocuments'][string],\n      ) => {\n        await originalDocumentTable.addItem({ workspaceId, documentName }, { data })\n      },\n    },\n    intermediateDocuments: {\n      /**\n       * Set an intermediate (transformed) document for a workspace/document pair.\n       */\n      setItem: async (\n        workspaceId: string,\n        documentName: string,\n        data: InMemoryWorkspace['intermediateDocuments'][string],\n      ) => {\n        await intermediateDocumentTable.addItem({ workspaceId, documentName }, { data })\n      },\n    },\n    overrides: {\n      /**\n       * Set document overrides for a workspace/document pair.\n       */\n      setItem: async (workspaceId: string, documentName: string, data: InMemoryWorkspace['overrides'][string]) => {\n        await overridesTable.addItem({ workspaceId, documentName }, { data })\n      },\n    },\n    documentConfigs: {\n      /**\n       * Set configuration for a document in a workspace.\n       */\n      setItem: async (\n        workspaceId: string,\n        documentName: string,\n        data: InMemoryWorkspace['documentConfigs'][string],\n      ) => {\n        await documentConfigsTable.addItem({ workspaceId, documentName }, { data })\n      },\n    },\n    workspace: {\n      /**\n       * Retrieves a workspace by its ID.\n       * Returns undefined if the workspace does not exist.\n       * Gathers all workspace 'chunk' tables and assembles a full workspace shape.\n       */\n      getItem: async (id: string): Promise<(WorkspaceStoreShape & { id: string }) | undefined> => {\n        const workspace = await workspaceTable.getItem({ id })\n\n        if (!workspace) {\n          return undefined\n        }\n\n        // Retrieve all chunk records for this workspace.\n        const workspaceDocuments = await documentsTable.getRange([id])\n        const workspaceOriginalDocuments = await originalDocumentTable.getRange([id])\n        const workspaceIntermediateDocuments = await intermediateDocumentTable.getRange([id])\n        const workspaceOverrides = await overridesTable.getRange([id])\n        const workspaceMeta = await metaTable.getItem({ workspaceId: id })\n        const workspaceDocumentConfigs = await documentConfigsTable.getRange([id])\n\n        // Compose the workspace structure from table records.\n        return {\n          id,\n          name: workspace.name,\n          workspace: {\n            documents: Object.fromEntries(workspaceDocuments.map((item) => [item.documentName, item.data])),\n            originalDocuments: Object.fromEntries(\n              workspaceOriginalDocuments.map((item) => [item.documentName, item.data]),\n            ),\n            intermediateDocuments: Object.fromEntries(\n              workspaceIntermediateDocuments.map((item) => [item.documentName, item.data]),\n            ),\n            overrides: Object.fromEntries(workspaceOverrides.map((item) => [item.documentName, item.data])),\n            meta: workspaceMeta?.data,\n            documentConfigs: Object.fromEntries(workspaceDocumentConfigs.map((item) => [item.documentName, item.data])),\n          },\n        }\n      },\n\n      /**\n       * Retrieves all workspaces from the database.\n       * Returns only the workspace ID and name for each workspace.\n       * To get the full workspace data including documents and metadata, use getItem() with a specific ID.\n       * Returns an empty array if no workspaces exist.\n       */\n      getAll: async () => {\n        return await workspaceTable.getAll()\n      },\n\n      /**\n       * Saves a workspace to the database.\n       * All chunks (meta, documents, configs, etc.) are upsert in their respective tables.\n       * If a workspace with the same ID already exists, it will be replaced.\n       */\n      setItem: async (id: string, value: WorkspaceStoreShape): Promise<void> => {\n        await workspaceTable.addItem({ id }, { name: value.name })\n\n        // Save all meta info for workspace.\n        await metaTable.addItem({ workspaceId: id }, { data: value.workspace.meta })\n\n        // Persist all workspace documents (chunks).\n        await Promise.all(\n          Object.entries(value.workspace.documents ?? {}).map(([name, data]) => {\n            return documentsTable.addItem({ workspaceId: id, documentName: name }, { data })\n          }),\n        )\n\n        // Persist all original documents.\n        await Promise.all(\n          Object.entries(value.workspace.originalDocuments ?? {}).map(([name, data]) => {\n            return originalDocumentTable.addItem({ workspaceId: id, documentName: name }, { data })\n          }),\n        )\n\n        // Persist all intermediate documents.\n        await Promise.all(\n          Object.entries(value.workspace.intermediateDocuments ?? {}).map(([name, data]) => {\n            return intermediateDocumentTable.addItem({ workspaceId: id, documentName: name }, { data })\n          }),\n        )\n\n        // Persist all document overrides.\n        await Promise.all(\n          Object.entries(value.workspace.overrides ?? {}).map(([name, data]) => {\n            return overridesTable.addItem({ workspaceId: id, documentName: name }, { data })\n          }),\n        )\n\n        // Persist all document configs.\n        await Promise.all(\n          Object.entries(value.workspace.documentConfigs ?? {}).map(([name, data]) => {\n            return documentConfigsTable.addItem({ workspaceId: id, documentName: name }, { data })\n          }),\n        )\n      },\n\n      /**\n       * Deletes an entire workspace and all associated chunk records from all tables by ID.\n       */\n      deleteItem: async (id: string): Promise<void> => {\n        await workspaceTable.deleteItem({ id })\n\n        // Remove all workspace-related records from all chunk tables.\n        await Promise.all([\n          // By id\n          metaTable.deleteItem({ workspaceId: id }),\n\n          // By range (composite-key tables)\n          documentsTable.deleteRange([id]),\n          originalDocumentTable.deleteRange([id]),\n          intermediateDocumentTable.deleteRange([id]),\n          overridesTable.deleteRange([id]),\n          documentConfigsTable.deleteRange([id]),\n        ])\n      },\n    },\n  }\n}\n"],
  "mappings": "AAAA,SAAS,YAAY;AAErB,SAAS,+BAA+B;AAkBjC,MAAM,kCAAkC,YAAY;AAEzD,QAAM,aAAa,MAAM,wBAAwB;AAAA,IAC/C,MAAM;AAAA,IACN,SAAS;AAAA,IACT,QAAQ;AAAA,MACN,WAAW;AAAA,QACT,QAAQ,KAAK,OAAO,EAAE,IAAI,KAAK,OAAO,GAAG,MAAM,KAAK,OAAO,EAAE,CAAC;AAAA,QAC9D,OAAO,CAAC,IAAI;AAAA,MACd;AAAA,MACA,MAAM;AAAA,QACJ,QAAQ,KAAK,OAAO,EAAE,aAAa,KAAK,OAAO,GAAG,MAAM,KAAK,IAAI,EAAE,CAAC;AAAA,QACpE,OAAO,CAAC,aAAa;AAAA,MACvB;AAAA,MACA,WAAW;AAAA,QACT,QAAQ,KAAK,OAAO,EAAE,aAAa,KAAK,OAAO,GAAG,cAAc,KAAK,OAAO,GAAG,MAAM,KAAK,IAAI,EAAE,CAAC;AAAA,QACjG,OAAO,CAAC,eAAe,cAAc;AAAA,MACvC;AAAA,MACA,mBAAmB;AAAA,QACjB,QAAQ,KAAK,OAAO,EAAE,aAAa,KAAK,OAAO,GAAG,cAAc,KAAK,OAAO,GAAG,MAAM,KAAK,IAAI,EAAE,CAAC;AAAA,QACjG,OAAO,CAAC,eAAe,cAAc;AAAA,MACvC;AAAA,MACA,uBAAuB;AAAA,QACrB,QAAQ,KAAK,OAAO,EAAE,aAAa,KAAK,OAAO,GAAG,cAAc,KAAK,OAAO,GAAG,MAAM,KAAK,IAAI,EAAE,CAAC;AAAA,QACjG,OAAO,CAAC,eAAe,cAAc;AAAA,MACvC;AAAA,MACA,WAAW;AAAA,QACT,QAAQ,KAAK,OAAO,EAAE,aAAa,KAAK,OAAO,GAAG,cAAc,KAAK,OAAO,GAAG,MAAM,KAAK,IAAI,EAAE,CAAC;AAAA,QACjG,OAAO,CAAC,eAAe,cAAc;AAAA,MACvC;AAAA,MACA,iBAAiB;AAAA,QACf,QAAQ,KAAK,OAAO,EAAE,aAAa,KAAK,OAAO,GAAG,cAAc,KAAK,OAAO,GAAG,MAAM,KAAK,IAAI,EAAE,CAAC;AAAA,QACjG,OAAO,CAAC,eAAe,cAAc;AAAA,MACvC;AAAA,IACF;AAAA,EACF,CAAC;AAGD,QAAM,iBAAiB,WAAW,IAAI,WAAW;AACjD,QAAM,YAAY,WAAW,IAAI,MAAM;AACvC,QAAM,iBAAiB,WAAW,IAAI,WAAW;AACjD,QAAM,wBAAwB,WAAW,IAAI,mBAAmB;AAChE,QAAM,4BAA4B,WAAW,IAAI,uBAAuB;AACxE,QAAM,iBAAiB,WAAW,IAAI,WAAW;AACjD,QAAM,uBAAuB,WAAW,IAAI,iBAAiB;AAG7D,SAAO;AAAA,IACL,OAAO,MAAM;AACX,iBAAW,cAAc;AAAA,IAC3B;AAAA,IACA,MAAM;AAAA;AAAA;AAAA;AAAA,MAIJ,SAAS,OAAO,aAAqB,SAAwB;AAC3D,cAAM,UAAU,QAAQ,EAAE,YAAY,GAAG,EAAE,KAAK,CAAC;AAAA,MACnD;AAAA,IACF;AAAA,IACA,WAAW;AAAA;AAAA;AAAA;AAAA,MAIT,SAAS,OAAO,aAAqB,cAAsB,SAAiD;AAC1G,cAAM,eAAe,QAAQ,EAAE,aAAa,aAAa,GAAG,EAAE,KAAK,CAAC;AAAA,MACtE;AAAA,IACF;AAAA,IACA,mBAAmB;AAAA;AAAA;AAAA;AAAA,MAIjB,SAAS,OACP,aACA,cACA,SACG;AACH,cAAM,sBAAsB,QAAQ,EAAE,aAAa,aAAa,GAAG,EAAE,KAAK,CAAC;AAAA,MAC7E;AAAA,IACF;AAAA,IACA,uBAAuB;AAAA;AAAA;AAAA;AAAA,MAIrB,SAAS,OACP,aACA,cACA,SACG;AACH,cAAM,0BAA0B,QAAQ,EAAE,aAAa,aAAa,GAAG,EAAE,KAAK,CAAC;AAAA,MACjF;AAAA,IACF;AAAA,IACA,WAAW;AAAA;AAAA;AAAA;AAAA,MAIT,SAAS,OAAO,aAAqB,cAAsB,SAAiD;AAC1G,cAAM,eAAe,QAAQ,EAAE,aAAa,aAAa,GAAG,EAAE,KAAK,CAAC;AAAA,MACtE;AAAA,IACF;AAAA,IACA,iBAAiB;AAAA;AAAA;AAAA;AAAA,MAIf,SAAS,OACP,aACA,cACA,SACG;AACH,cAAM,qBAAqB,QAAQ,EAAE,aAAa,aAAa,GAAG,EAAE,KAAK,CAAC;AAAA,MAC5E;AAAA,IACF;AAAA,IACA,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMT,SAAS,OAAO,OAA4E;AAC1F,cAAM,YAAY,MAAM,eAAe,QAAQ,EAAE,GAAG,CAAC;AAErD,YAAI,CAAC,WAAW;AACd,iBAAO;AAAA,QACT;AAGA,cAAM,qBAAqB,MAAM,eAAe,SAAS,CAAC,EAAE,CAAC;AAC7D,cAAM,6BAA6B,MAAM,sBAAsB,SAAS,CAAC,EAAE,CAAC;AAC5E,cAAM,iCAAiC,MAAM,0BAA0B,SAAS,CAAC,EAAE,CAAC;AACpF,cAAM,qBAAqB,MAAM,eAAe,SAAS,CAAC,EAAE,CAAC;AAC7D,cAAM,gBAAgB,MAAM,UAAU,QAAQ,EAAE,aAAa,GAAG,CAAC;AACjE,cAAM,2BAA2B,MAAM,qBAAqB,SAAS,CAAC,EAAE,CAAC;AAGzE,eAAO;AAAA,UACL;AAAA,UACA,MAAM,UAAU;AAAA,UAChB,WAAW;AAAA,YACT,WAAW,OAAO,YAAY,mBAAmB,IAAI,CAAC,SAAS,CAAC,KAAK,cAAc,KAAK,IAAI,CAAC,CAAC;AAAA,YAC9F,mBAAmB,OAAO;AAAA,cACxB,2BAA2B,IAAI,CAAC,SAAS,CAAC,KAAK,cAAc,KAAK,IAAI,CAAC;AAAA,YACzE;AAAA,YACA,uBAAuB,OAAO;AAAA,cAC5B,+BAA+B,IAAI,CAAC,SAAS,CAAC,KAAK,cAAc,KAAK,IAAI,CAAC;AAAA,YAC7E;AAAA,YACA,WAAW,OAAO,YAAY,mBAAmB,IAAI,CAAC,SAAS,CAAC,KAAK,cAAc,KAAK,IAAI,CAAC,CAAC;AAAA,YAC9F,MAAM,eAAe;AAAA,YACrB,iBAAiB,OAAO,YAAY,yBAAyB,IAAI,CAAC,SAAS,CAAC,KAAK,cAAc,KAAK,IAAI,CAAC,CAAC;AAAA,UAC5G;AAAA,QACF;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQA,QAAQ,YAAY;AAClB,eAAO,MAAM,eAAe,OAAO;AAAA,MACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,SAAS,OAAO,IAAY,UAA8C;AACxE,cAAM,eAAe,QAAQ,EAAE,GAAG,GAAG,EAAE,MAAM,MAAM,KAAK,CAAC;AAGzD,cAAM,UAAU,QAAQ,EAAE,aAAa,GAAG,GAAG,EAAE,MAAM,MAAM,UAAU,KAAK,CAAC;AAG3E,cAAM,QAAQ;AAAA,UACZ,OAAO,QAAQ,MAAM,UAAU,aAAa,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,MAAM,IAAI,MAAM;AACpE,mBAAO,eAAe,QAAQ,EAAE,aAAa,IAAI,cAAc,KAAK,GAAG,EAAE,KAAK,CAAC;AAAA,UACjF,CAAC;AAAA,QACH;AAGA,cAAM,QAAQ;AAAA,UACZ,OAAO,QAAQ,MAAM,UAAU,qBAAqB,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,MAAM,IAAI,MAAM;AAC5E,mBAAO,sBAAsB,QAAQ,EAAE,aAAa,IAAI,cAAc,KAAK,GAAG,EAAE,KAAK,CAAC;AAAA,UACxF,CAAC;AAAA,QACH;AAGA,cAAM,QAAQ;AAAA,UACZ,OAAO,QAAQ,MAAM,UAAU,yBAAyB,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,MAAM,IAAI,MAAM;AAChF,mBAAO,0BAA0B,QAAQ,EAAE,aAAa,IAAI,cAAc,KAAK,GAAG,EAAE,KAAK,CAAC;AAAA,UAC5F,CAAC;AAAA,QACH;AAGA,cAAM,QAAQ;AAAA,UACZ,OAAO,QAAQ,MAAM,UAAU,aAAa,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,MAAM,IAAI,MAAM;AACpE,mBAAO,eAAe,QAAQ,EAAE,aAAa,IAAI,cAAc,KAAK,GAAG,EAAE,KAAK,CAAC;AAAA,UACjF,CAAC;AAAA,QACH;AAGA,cAAM,QAAQ;AAAA,UACZ,OAAO,QAAQ,MAAM,UAAU,mBAAmB,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,MAAM,IAAI,MAAM;AAC1E,mBAAO,qBAAqB,QAAQ,EAAE,aAAa,IAAI,cAAc,KAAK,GAAG,EAAE,KAAK,CAAC;AAAA,UACvF,CAAC;AAAA,QACH;AAAA,MACF;AAAA;AAAA;AAAA;AAAA,MAKA,YAAY,OAAO,OAA8B;AAC/C,cAAM,eAAe,WAAW,EAAE,GAAG,CAAC;AAGtC,cAAM,QAAQ,IAAI;AAAA;AAAA,UAEhB,UAAU,WAAW,EAAE,aAAa,GAAG,CAAC;AAAA;AAAA,UAGxC,eAAe,YAAY,CAAC,EAAE,CAAC;AAAA,UAC/B,sBAAsB,YAAY,CAAC,EAAE,CAAC;AAAA,UACtC,0BAA0B,YAAY,CAAC,EAAE,CAAC;AAAA,UAC1C,eAAe,YAAY,CAAC,EAAE,CAAC;AAAA,UAC/B,qBAAqB,YAAY,CAAC,EAAE,CAAC;AAAA,QACvC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;",
  "names": []
}
