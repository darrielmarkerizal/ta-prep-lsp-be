{
  "version": 3,
  "sources": ["../../../src/navigation/helpers/traverse-tags.ts"],
  "sourcesContent": ["import { getXKeysFromObject } from '@/navigation/helpers/get-x-keys'\nimport type { TagsMap, TraverseSpecOptions } from '@/navigation/types'\nimport type { TraversedEntry, TraversedTag } from '@/schemas/navigation'\nimport type { OpenApiDocument, TagObject } from '@/schemas/v3.1/strict/openapi-document'\n\nimport { getTag } from './get-tag'\n\ntype Options = Pick<TraverseSpecOptions, 'tagsSorter' | 'operationsSorter' | 'generateId'>\n\n/** Creates a traversed tag entry from an OpenAPI tag object.\n *\n * @param tag - The OpenAPI tag object\n * @param entriesMap - Map to store tag IDs and titles for mobile header navigation\n * @param getTagId - Function to generate unique IDs for tags\n * @param children - Array of child entries (operations, webhooks, etc.)\n * @param isGroup - Whether this tag represents a group of tags\n * @returns A traversed tag entry with ID, title, name and children\n */\nconst createTagEntry = ({\n  tag,\n  generateId,\n  children,\n  isGroup = false,\n  parentId,\n}: {\n  tag: TagObject\n  generateId: TraverseSpecOptions['generateId']\n  children: TraversedEntry[]\n  isGroup: boolean\n  parentId: string\n}): TraversedTag => {\n  const id = generateId({\n    type: 'tag',\n    tag,\n    parentId,\n  })\n  const title = tag['x-displayName'] ?? tag.name ?? 'Untitled Tag'\n\n  const entry = {\n    id,\n    title,\n    name: tag.name || title,\n    description: tag.description,\n    children,\n    isGroup,\n    isWebhooks: false,\n    type: 'tag',\n    xKeys: getXKeysFromObject(tag),\n  } satisfies TraversedTag\n\n  return entry\n}\n\n/** Sorts and processes tags to create a hierarchical structure of tag entries.\n *\n * This function handles:\n * - Sorting tags alphabetically or using a custom sort function\n * - Ensuring the default tag appears last\n * - Sorting operations within tags by title, method, or custom function\n * - Filtering out internal and ignored tags\n * - Creating tag entries with their associated operations\n *\n * @param _keys - Array of tag keys to process\n * @param tagsMap - Map of tags and their entries\n * @param tagsDict - Dictionary of OpenAPI tags by name\n * @param titlesMap - Map of titles for the mobile header\n * @param options - Sorting and ID generation options\n * @returns Array of processed and sorted tag entries\n */\n/** Sorts tags and returns entries */\nconst getSortedTagEntries = ({\n  _keys,\n  tagsMap,\n  options: { tagsSorter, operationsSorter, generateId },\n  documentId,\n}: {\n  _keys: string[]\n  /** Map of tags and their entries */\n  tagsMap: TagsMap\n  options: Options\n  documentId: string\n}) => {\n  // Ensure that default is last if it exists\n  const hasDefault = _keys.includes('default')\n  const keys = hasDefault ? _keys.filter((key) => key !== 'default') : _keys\n\n  // Alpha sort\n  if (tagsSorter === 'alpha') {\n    keys.sort((a, b) => {\n      const nameA =\n        getTag({\n          tagsMap,\n          name: a,\n          documentId,\n          generateId,\n        }).tag['x-displayName'] ||\n        a ||\n        'Untitled Tag'\n      const nameB = getTag({ tagsMap, name: b, documentId, generateId }).tag['x-displayName'] || b || 'Untitled Tag'\n      return nameA.localeCompare(nameB)\n    })\n  }\n  // Custom sort\n  else if (typeof tagsSorter === 'function') {\n    keys.sort((a, b) =>\n      tagsSorter(\n        getTag({ tagsMap, name: a, documentId, generateId }).tag,\n        getTag({ tagsMap, name: b, documentId, generateId }).tag,\n      ),\n    )\n  }\n\n  if (hasDefault) {\n    keys.push('default')\n  }\n\n  /**\n   * Process each tag and its entries:\n   * - Skip internal and ignored tags\n   * - Sort operations within tags\n   * - Create tag entries with sorted operations\n   */\n  return keys.flatMap((key) => {\n    const { tag, entries } = getTag({ tagsMap, name: key, documentId, generateId })\n\n    // Skip if the tag is internal or scalar-ignore\n    if (tag['x-internal'] || tag['x-scalar-ignore']) {\n      return []\n    }\n\n    // Alpha sort\n    if (operationsSorter === 'alpha') {\n      entries.sort((a, b) => (a.type === 'operation' && b.type === 'operation' ? a.title.localeCompare(b.title) : 0))\n    }\n    // Method sort\n    else if (operationsSorter === 'method') {\n      entries.sort((a, b) => (a.type === 'operation' && b.type === 'operation' ? a.method.localeCompare(b.method) : 0))\n    }\n    // Custom sort\n    else if (typeof operationsSorter === 'function') {\n      entries.sort((a, b) => {\n        // Guard against tags\n        if (!(a.type === 'operation' || a.type === 'webhook') || !(b.type === 'operation' || b.type === 'webhook')) {\n          return 0\n        }\n\n        // Handle webhooks as well as operations\n        const pathA = a.type === 'operation' ? a.path : a.name\n        const pathB = b.type === 'operation' ? b.path : b.name\n\n        return operationsSorter(\n          { method: a.method, path: pathA, ref: a.ref, httpVerb: a.method },\n          { method: b.method, path: pathB, ref: b.ref, httpVerb: b.method },\n        )\n      })\n    }\n\n    return entries.length\n      ? createTagEntry({\n          tag,\n          generateId,\n          children: entries,\n          parentId: documentId,\n          isGroup: false,\n        })\n      : []\n  })\n}\n\n/**\n * Traverses the tags map to create navigation entries, handling both grouped and ungrouped tags.\n *\n * This function processes the OpenAPI document's tags to:\n * - Handle tag groups if specified via x-tagGroups\n * - Sort tags and their operations according to provided sorters\n * - Create navigation entries for each tag or tag group\n * - Flatten default tag entries if it's the only tag present\n */\nexport const traverseTags = ({\n  document,\n  tagsMap,\n  documentId,\n  options: { generateId, tagsSorter, operationsSorter },\n}: {\n  document: OpenApiDocument\n  /** Map of tags and their entries */\n  tagsMap: TagsMap\n  documentId: string\n  options: Options\n}): TraversedEntry[] => {\n  // x-tagGroups\n  if (document['x-tagGroups']) {\n    const tagGroups = document['x-tagGroups']\n\n    return tagGroups.flatMap((tagGroup) => {\n      const entries = getSortedTagEntries({\n        _keys: tagGroup.tags,\n        tagsMap,\n        options: { tagsSorter, operationsSorter, generateId },\n        documentId: documentId,\n      })\n      return entries.length\n        ? createTagEntry({\n            tag: tagGroup,\n            generateId,\n            children: entries,\n            parentId: documentId,\n            isGroup: true,\n          })\n        : []\n    })\n  }\n\n  // Ungrouped regular tags\n  const keys = Array.from(tagsMap.keys())\n  const tags = getSortedTagEntries({\n    _keys: keys,\n    tagsMap,\n    options: { generateId, tagsSorter, operationsSorter },\n    documentId: documentId,\n  })\n\n  // Flatten if we only have default tag\n  if (tags.length === 1 && tags[0]?.title === 'default') {\n    return tags[0]?.children ?? []\n  }\n\n  return tags\n}\n"],
  "mappings": "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",
  "names": []
}
