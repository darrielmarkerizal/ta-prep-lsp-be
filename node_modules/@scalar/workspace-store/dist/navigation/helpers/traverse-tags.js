import { getXKeysFromObject } from "../../navigation/helpers/get-x-keys.js";
import { getTag } from "./get-tag.js";
const createTagEntry = ({
  tag,
  generateId,
  children,
  isGroup = false,
  parentId
}) => {
  const id = generateId({
    type: "tag",
    tag,
    parentId
  });
  const title = tag["x-displayName"] ?? tag.name ?? "Untitled Tag";
  const entry = {
    id,
    title,
    name: tag.name || title,
    description: tag.description,
    children,
    isGroup,
    isWebhooks: false,
    type: "tag",
    xKeys: getXKeysFromObject(tag)
  };
  return entry;
};
const getSortedTagEntries = ({
  _keys,
  tagsMap,
  options: { tagsSorter, operationsSorter, generateId },
  documentId
}) => {
  const hasDefault = _keys.includes("default");
  const keys = hasDefault ? _keys.filter((key) => key !== "default") : _keys;
  if (tagsSorter === "alpha") {
    keys.sort((a, b) => {
      const nameA = getTag({
        tagsMap,
        name: a,
        documentId,
        generateId
      }).tag["x-displayName"] || a || "Untitled Tag";
      const nameB = getTag({ tagsMap, name: b, documentId, generateId }).tag["x-displayName"] || b || "Untitled Tag";
      return nameA.localeCompare(nameB);
    });
  } else if (typeof tagsSorter === "function") {
    keys.sort(
      (a, b) => tagsSorter(
        getTag({ tagsMap, name: a, documentId, generateId }).tag,
        getTag({ tagsMap, name: b, documentId, generateId }).tag
      )
    );
  }
  if (hasDefault) {
    keys.push("default");
  }
  return keys.flatMap((key) => {
    const { tag, entries } = getTag({ tagsMap, name: key, documentId, generateId });
    if (tag["x-internal"] || tag["x-scalar-ignore"]) {
      return [];
    }
    if (operationsSorter === "alpha") {
      entries.sort((a, b) => a.type === "operation" && b.type === "operation" ? a.title.localeCompare(b.title) : 0);
    } else if (operationsSorter === "method") {
      entries.sort((a, b) => a.type === "operation" && b.type === "operation" ? a.method.localeCompare(b.method) : 0);
    } else if (typeof operationsSorter === "function") {
      entries.sort((a, b) => {
        if (!(a.type === "operation" || a.type === "webhook") || !(b.type === "operation" || b.type === "webhook")) {
          return 0;
        }
        const pathA = a.type === "operation" ? a.path : a.name;
        const pathB = b.type === "operation" ? b.path : b.name;
        return operationsSorter(
          { method: a.method, path: pathA, ref: a.ref, httpVerb: a.method },
          { method: b.method, path: pathB, ref: b.ref, httpVerb: b.method }
        );
      });
    }
    return entries.length ? createTagEntry({
      tag,
      generateId,
      children: entries,
      parentId: documentId,
      isGroup: false
    }) : [];
  });
};
const traverseTags = ({
  document,
  tagsMap,
  documentId,
  options: { generateId, tagsSorter, operationsSorter }
}) => {
  if (document["x-tagGroups"]) {
    const tagGroups = document["x-tagGroups"];
    return tagGroups.flatMap((tagGroup) => {
      const entries = getSortedTagEntries({
        _keys: tagGroup.tags,
        tagsMap,
        options: { tagsSorter, operationsSorter, generateId },
        documentId
      });
      return entries.length ? createTagEntry({
        tag: tagGroup,
        generateId,
        children: entries,
        parentId: documentId,
        isGroup: true
      }) : [];
    });
  }
  const keys = Array.from(tagsMap.keys());
  const tags = getSortedTagEntries({
    _keys: keys,
    tagsMap,
    options: { generateId, tagsSorter, operationsSorter },
    documentId
  });
  if (tags.length === 1 && tags[0]?.title === "default") {
    return tags[0]?.children ?? [];
  }
  return tags;
};
export {
  traverseTags
};
//# sourceMappingURL=traverse-tags.js.map
