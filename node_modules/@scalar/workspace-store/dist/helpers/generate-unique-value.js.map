{
  "version": 3,
  "sources": ["../../src/helpers/generate-unique-value.ts"],
  "sourcesContent": ["/**\n * Generates a unique value based on a given default value and a validation function.\n *\n * The process works as follows:\n * 1. Optionally transform (e.g., slugify) the default value using a transformation function.\n * 2. Check if this value is unique by executing the provided validation function.\n * 3. If not unique, repeatedly append an incrementing integer (e.g., \"my-name 1\", \"my-name 2\", ...) and re-check uniqueness,\n *    up to a maximum number of attempts (maxRetries).\n * 4. Returns the first unique value found or undefined if a unique value cannot be generated within the maximum retries.\n *\n * Example:\n * ```ts\n * // Existing names in use\n * const existing = new Set(['foo', 'foo 1', 'foo 2']);\n * const uniqueName = generateUniqueValue({\n *   defaultValue: 'foo',\n *   validation: (value) => !existing.has(value),\n *   // transformation is optional, e.g. (val) => val.toLowerCase().replace(/[^\\w]+/g, '-'),\n *   maxRetries: 10,\n * });\n * // uniqueName === 'foo 3'\n * ```\n */\nexport function generateUniqueValue({\n  defaultValue,\n  /** Check function to verify the uniqueness of the value */\n  validation,\n  /** Transformation function to transform the default value (such as into a slug) */\n  transformation,\n  maxRetries = 5,\n}: {\n  /**\n   * Value which will be used to derive a new unique value.\n   */\n  defaultValue: string\n  /** Validate if the new generated value is unique */\n  validation: (value: string) => Promise<boolean> | boolean\n  /** Transform the default value to get a new value which will match the schema of the value we need to derive */\n  transformation?: (value: string) => string\n  /** The maximum number of retry attempts to generate a unique value. */\n  maxRetries: number\n}) {\n  const transformed = transformation?.(defaultValue) ?? defaultValue\n\n  if (validation(transformed)) {\n    return transformed\n  }\n\n  return incrementValue({\n    value: [transformed, 1],\n    validation,\n    maxRetries,\n  })\n}\n\n/**\n * Attempts to generate a unique value by appending and incrementing a counter to a base string.\n *\n * On each attempt, appends the next incrementing integer (e.g. \"foo 1\", \"foo 2\", etc.) to the original value,\n * and checks with the validation function whether the candidate value is unique.\n *\n * Continues until a unique value is found, or the maximum number of attempts is reached.\n *\n * Returns the first unique value found, or undefined if a unique value cannot be generated within maxRetries.\n *\n * Example:\n * ```ts\n * const existing = new Set(['bar', 'bar 1']);\n * const result = incrementValue({\n *   value: ['bar', 1],\n *   validation: (val) => !existing.has(val),\n *   maxRetries: 5,\n * });\n * // result === \"bar 2\"\n * ```\n */\nfunction incrementValue({\n  value,\n  validation,\n  maxRetries,\n  attempts = 0,\n}: {\n  value: [string, number] // [base value, next increment]\n  validation: (value: string) => Promise<boolean> | boolean\n  maxRetries: number\n  attempts?: number\n}) {\n  if (attempts >= maxRetries) {\n    return\n  }\n\n  const incremented = value.join(' ')\n\n  if (validation(incremented)) {\n    return incremented\n  }\n\n  return incrementValue({\n    value: [value[0], value[1] + 1],\n    validation,\n    maxRetries,\n    attempts: attempts + 1,\n  })\n}\n"],
  "mappings": "AAuBO,SAAS,oBAAoB;AAAA,EAClC;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA,EACA,aAAa;AACf,GAWG;AACD,QAAM,cAAc,iBAAiB,YAAY,KAAK;AAEtD,MAAI,WAAW,WAAW,GAAG;AAC3B,WAAO;AAAA,EACT;AAEA,SAAO,eAAe;AAAA,IACpB,OAAO,CAAC,aAAa,CAAC;AAAA,IACtB;AAAA,IACA;AAAA,EACF,CAAC;AACH;AAuBA,SAAS,eAAe;AAAA,EACtB;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAW;AACb,GAKG;AACD,MAAI,YAAY,YAAY;AAC1B;AAAA,EACF;AAEA,QAAM,cAAc,MAAM,KAAK,GAAG;AAElC,MAAI,WAAW,WAAW,GAAG;AAC3B,WAAO;AAAA,EACT;AAEA,SAAO,eAAe;AAAA,IACpB,OAAO,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC;AAAA,IAC9B;AAAA,IACA;AAAA,IACA,UAAU,WAAW;AAAA,EACvB,CAAC;AACH;",
  "names": []
}
