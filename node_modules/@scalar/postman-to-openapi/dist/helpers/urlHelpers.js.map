{
  "version": 3,
  "sources": ["../../src/helpers/urlHelpers.ts"],
  "sourcesContent": ["import { REGEX } from '@scalar/helpers/regex/regex-helpers'\n\nimport type { ParsedUrl } from '../types'\n\n/**\n * Parses a URL string into its component parts.\n */\nfunction parseUrl(urlString: string): ParsedUrl {\n  const url = new URL(urlString)\n  return {\n    protocol: url.protocol,\n    hostname: url.hostname,\n    port: url.port,\n  }\n}\n\n/**\n * Extracts the domain (including protocol and port if present) from a given URL.\n */\nexport function getDomainFromUrl(url: string): string {\n  const { protocol, hostname, port } = parseUrl(url)\n  return `${protocol}//${hostname}${port ? `:${port}` : ''}`\n}\n\n/**\n * Extracts the path from a given URL, removing any Postman variables.\n */\nexport function extractPathFromUrl(url: string | undefined): string {\n  if (!url) {\n    return '/'\n  }\n\n  // Remove scheme, domain, query parameters, and hash fragments\n  const path = url.replace(/^(?:https?:\\/\\/)?[^/]+(\\/|$)/, '/').split(/[?#]/)[0] ?? ''\n\n  // Replace Postman variables and ensure single leading slash\n  const finalPath = ('/' + path.replace(/\\{\\{([^{}]{0,1000})\\}\\}/g, '{$1}').replace(/^\\/+/, '')).replace(/\\/\\/+/g, '/')\n\n  return finalPath\n}\n\n/**\n * Normalizes a path by converting colon-style parameters to curly brace style\n * e.g., '/users/:id' becomes '/users/{id}'\n */\nexport const normalizePath = (path: string): string => path.replace(/:(\\w+)/g, '{$1}')\n\n/**\n * Extracts parameter names from a path string.\n * Handles double curly braces {{param}}, single curly braces {param}, and colon format :param.\n */\nexport function extractPathParameterNames(path: string): string[] {\n  const params = new Set<string>()\n  let match\n\n  while ((match = REGEX.TEMPLATE_VARIABLE.exec(path)) !== null) {\n    // match[1] contains the parameter name from {{param}}\n    // match[2] contains the parameter name from {param}\n    // match[0].slice(1) gets the parameter name from :param\n    const param = match[1] || match[2] || match[0].slice(1)\n    params.add(param.trim())\n  }\n\n  return Array.from(params)\n}\n"],
  "mappings": "AAAA,SAAS,aAAa;AAOtB,SAAS,SAAS,WAA8B;AAC9C,QAAM,MAAM,IAAI,IAAI,SAAS;AAC7B,SAAO;AAAA,IACL,UAAU,IAAI;AAAA,IACd,UAAU,IAAI;AAAA,IACd,MAAM,IAAI;AAAA,EACZ;AACF;AAKO,SAAS,iBAAiB,KAAqB;AACpD,QAAM,EAAE,UAAU,UAAU,KAAK,IAAI,SAAS,GAAG;AACjD,SAAO,GAAG,QAAQ,KAAK,QAAQ,GAAG,OAAO,IAAI,IAAI,KAAK,EAAE;AAC1D;AAKO,SAAS,mBAAmB,KAAiC;AAClE,MAAI,CAAC,KAAK;AACR,WAAO;AAAA,EACT;AAGA,QAAM,OAAO,IAAI,QAAQ,gCAAgC,GAAG,EAAE,MAAM,MAAM,EAAE,CAAC,KAAK;AAGlF,QAAM,aAAa,MAAM,KAAK,QAAQ,4BAA4B,MAAM,EAAE,QAAQ,QAAQ,EAAE,GAAG,QAAQ,UAAU,GAAG;AAEpH,SAAO;AACT;AAMO,MAAM,gBAAgB,CAAC,SAAyB,KAAK,QAAQ,WAAW,MAAM;AAM9E,SAAS,0BAA0B,MAAwB;AAChE,QAAM,SAAS,oBAAI,IAAY;AAC/B,MAAI;AAEJ,UAAQ,QAAQ,MAAM,kBAAkB,KAAK,IAAI,OAAO,MAAM;AAI5D,UAAM,QAAQ,MAAM,CAAC,KAAK,MAAM,CAAC,KAAK,MAAM,CAAC,EAAE,MAAM,CAAC;AACtD,WAAO,IAAI,MAAM,KAAK,CAAC;AAAA,EACzB;AAEA,SAAO,MAAM,KAAK,MAAM;AAC1B;",
  "names": []
}
