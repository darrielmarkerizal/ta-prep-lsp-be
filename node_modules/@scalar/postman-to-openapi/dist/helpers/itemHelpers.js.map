{
  "version": 3,
  "sources": ["../../src/helpers/itemHelpers.ts"],
  "sourcesContent": ["import type { OpenAPIV3_1 } from '@scalar/openapi-types'\n\nimport type { Item, ItemGroup } from '../types'\nimport { processAuth } from './authHelpers'\nimport { parseMdTable } from './md-utils'\nimport { extractParameters } from './parameterHelpers'\nimport { processPostResponseScripts } from './postResponseScripts'\nimport { extractRequestBody } from './requestBodyHelpers'\nimport { extractResponses } from './responseHelpers'\nimport { extractPathFromUrl, extractPathParameterNames, normalizePath } from './urlHelpers'\n\ntype HttpMethods = 'get' | 'put' | 'post' | 'delete' | 'options' | 'head' | 'patch' | 'trace'\n\n/**\n * Processes a Postman collection item or item group and returns\n * the corresponding OpenAPI paths and components.\n * Handles nested item groups, extracts request details, and generates corresponding\n * OpenAPI path items and operations.\n */\nexport function processItem(\n  item: Item | ItemGroup,\n  parentTags: string[] = [],\n  parentPath: string = '',\n): {\n  paths: OpenAPIV3_1.PathsObject\n  components: OpenAPIV3_1.ComponentsObject\n} {\n  const paths: OpenAPIV3_1.PathsObject = {}\n  const components: OpenAPIV3_1.ComponentsObject = {}\n\n  if ('item' in item && Array.isArray(item.item)) {\n    const newParentTags = item.name ? [...parentTags, item.name] : parentTags\n    item.item.forEach((childItem) => {\n      const childResult = processItem(childItem, newParentTags, `${parentPath}/${item.name || ''}`)\n      // Merge child paths and components\n      for (const [pathKey, pathItem] of Object.entries(childResult.paths)) {\n        if (!paths[pathKey]) {\n          paths[pathKey] = pathItem\n        } else {\n          paths[pathKey] = {\n            ...paths[pathKey],\n            ...pathItem,\n          }\n        }\n      }\n\n      // Merge components.securitySchemes\n      if (childResult.components.securitySchemes) {\n        components.securitySchemes = {\n          ...components.securitySchemes,\n          ...childResult.components.securitySchemes,\n        }\n      }\n    })\n    return { paths, components }\n  }\n\n  if (!('request' in item)) {\n    return { paths, components }\n  }\n\n  const { request, name, response } = item\n  const method = (typeof request === 'string' ? 'get' : request.method || 'get').toLowerCase() as HttpMethods\n\n  const path = extractPathFromUrl(\n    typeof request === 'string' ? request : typeof request.url === 'string' ? request.url : (request.url?.raw ?? ''),\n  )\n\n  // Normalize path parameters from ':param' to '{param}'\n  const normalizedPath = normalizePath(path)\n\n  // Extract path parameter names\n  const pathParameterNames = extractPathParameterNames(normalizedPath)\n\n  // Extract operation ID if present\n  const { operationId, summary } = extractOperationInfo(name)\n\n  const description =\n    typeof request === 'string'\n      ? ''\n      : typeof request.description === 'string'\n        ? request.description\n        : (request.description?.content ?? '')\n\n  const operationObject: OpenAPIV3_1.OperationObject = {\n    tags: parentTags.length > 0 ? [parentTags.join(' > ')] : undefined,\n    summary,\n    description,\n    responses: extractResponses(response || [], item),\n    parameters: [],\n  }\n\n  // Add post-response scripts if present\n  const postResponseScript = processPostResponseScripts(item.event)\n  if (postResponseScript) {\n    operationObject['x-post-response'] = postResponseScript\n  }\n\n  // Only add operationId if it was explicitly provided\n  if (operationId) {\n    operationObject.operationId = operationId\n  }\n\n  // Parse parameters from the description's Markdown table\n  if (operationObject.description) {\n    const { descriptionWithoutTable, parametersFromTable } = parseParametersFromDescription(operationObject.description)\n    operationObject.description = descriptionWithoutTable.trim()\n\n    // Extract parameters from the request (query, path, header)\n    const extractedParameters = extractParameters(request)\n\n    // Merge parameters, giving priority to those from the Markdown table\n    const mergedParameters = new Map<string, OpenAPIV3_1.ParameterObject>()\n\n    // Add extracted parameters, filtering out path parameters not in the path\n    extractedParameters.forEach((param) => {\n      if (param.name) {\n        if (param.in === 'path' && !pathParameterNames.includes(param.name)) {\n          return\n        }\n        mergedParameters.set(param.name, param)\n      }\n    })\n\n    // Add parameters from table, filtering out path parameters not in the path\n    parametersFromTable.forEach((param) => {\n      if (param.name) {\n        if (param.in === 'path' && !pathParameterNames.includes(param.name)) {\n          return\n        }\n        mergedParameters.set(param.name, param)\n      }\n    })\n\n    operationObject.parameters = Array.from(mergedParameters.values())\n  }\n\n  if (typeof request !== 'string' && request.auth) {\n    if (!operationObject.security) {\n      operationObject.security = []\n    }\n    const { securitySchemes, security } = processAuth(request.auth)\n\n    if (!components.securitySchemes) {\n      components.securitySchemes = {}\n    }\n    components.securitySchemes = {\n      ...components.securitySchemes,\n      ...securitySchemes,\n    }\n\n    operationObject.security.push(...security)\n  }\n\n  if (['post', 'put', 'patch'].includes(method) && typeof request !== 'string' && request.body) {\n    operationObject.requestBody = extractRequestBody(request.body)\n  }\n\n  if (!paths[path]) {\n    paths[path] = {}\n  }\n  const pathItem = paths[path] as OpenAPIV3_1.PathItemObject\n  pathItem[method] = operationObject\n\n  return { paths, components }\n}\n\n// Helper function to parse parameters from the description if it is markdown\nfunction parseParametersFromDescription(description: string): {\n  descriptionWithoutTable: string\n  parametersFromTable: OpenAPIV3_1.ParameterObject[]\n} {\n  const lines = description.split('\\n')\n  let inTable = false\n  const tableLines: string[] = []\n  const descriptionLines: string[] = []\n\n  for (const line of lines) {\n    // Detect the start of the table\n    if (line.trim().startsWith('|')) {\n      // Remove any preceding headers or empty lines before the table\n      while (\n        descriptionLines.length > 0 &&\n        (descriptionLines[descriptionLines.length - 1]?.trim() === '' ||\n          descriptionLines[descriptionLines.length - 1]?.trim().startsWith('#'))\n      ) {\n        descriptionLines.pop()\n      }\n\n      // Start collecting table lines\n      inTable = true\n    }\n\n    if (inTable) {\n      tableLines.push(line)\n      // Detect the end of the table (any line that doesn't start with '|', excluding the alignment line)\n      if (!line.trim().startsWith('|') && !line.trim().match(/^-+$/)) {\n        inTable = false\n      }\n    } else {\n      descriptionLines.push(line)\n    }\n  }\n\n  const tableMarkdown = tableLines.join('\\n')\n  const parsedTable = parseMdTable(tableMarkdown)\n  const parametersFromTable = Object.values(parsedTable).map((paramData: any) => {\n    const paramIn = paramData.object as 'query' | 'header' | 'path'\n\n    const param: OpenAPIV3_1.ParameterObject = {\n      name: paramData.name,\n      in: paramIn,\n      description: paramData.description,\n      required: paramData.required === 'true',\n      schema: {\n        type: paramData.type,\n      },\n    }\n\n    if (paramData.example) {\n      param.example = paramData.example\n    }\n\n    return param\n  })\n\n  const descriptionWithoutTable = descriptionLines.join('\\n')\n  return { descriptionWithoutTable, parametersFromTable }\n}\n\n// Instead of using regex with \\s*, let's split this into two steps\nfunction extractOperationInfo(name: string | undefined) {\n  if (!name) {\n    return { operationId: undefined, summary: undefined }\n  }\n\n  // First check if the string ends with something in brackets\n  const match = name.match(/\\[([^[\\]]{0,1000})\\]$/)\n  if (!match) {\n    return { operationId: undefined, summary: name }\n  }\n\n  // Get the operation ID from inside brackets\n  const operationId = match[1]\n\n  // Trim the brackets part from the end using string operations instead of regex\n  const lastBracketIndex = name.lastIndexOf('[')\n  const summary = name.substring(0, lastBracketIndex).trim()\n\n  return { operationId, summary }\n}\n"],
  "mappings": "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",
  "names": ["pathItem"]
}
