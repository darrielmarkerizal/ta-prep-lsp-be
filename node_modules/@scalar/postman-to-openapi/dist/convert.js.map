{
  "version": 3,
  "sources": ["../src/convert.ts"],
  "sourcesContent": ["import type { OpenAPIV3_1 } from '@scalar/openapi-types'\n\nimport { processAuth } from './helpers/authHelpers'\nimport { processExternalDocs } from './helpers/externalDocsHelper'\nimport { processItem } from './helpers/itemHelpers'\nimport { processLicenseAndContact } from './helpers/licenseContactHelper'\nimport { processLogo } from './helpers/logoHelper'\nimport { parseServers } from './helpers/serverHelpers'\nimport { normalizePath } from './helpers/urlHelpers'\nimport type { PostmanCollection } from './types'\n\n/**\n * Extracts tags from Postman collection folders\n */\nfunction extractTags(items: PostmanCollection['item']): OpenAPIV3_1.TagObject[] {\n  const tags: OpenAPIV3_1.TagObject[] = []\n\n  function processTagItem(item: any, parentPath: string = '') {\n    if (item.item) {\n      const currentPath = parentPath ? `${parentPath} > ${item.name}` : item.name\n\n      // Add tag for the current folder\n      tags.push({\n        name: currentPath,\n        ...(item.description && { description: item.description }),\n      })\n\n      // Process nested folders\n      item.item.forEach((subItem: any) => processTagItem(subItem, currentPath))\n    }\n  }\n\n  items.forEach((item) => processTagItem(item))\n  return tags\n}\n\n/**\n * Converts a Postman Collection to an OpenAPI 3.1.0 document.\n * This function processes the collection's information, servers, authentication,\n * and items to create a corresponding OpenAPI structure.\n */\nexport function convert(postmanCollection: PostmanCollection | string): OpenAPIV3_1.Document {\n  // Parse string input if provided\n  const collection: PostmanCollection =\n    typeof postmanCollection === 'string' ? JSON.parse(postmanCollection) : postmanCollection\n\n  // Extract title from collection info, fallback to 'API' if not provided\n  const title = collection.info.name || 'API'\n\n  // Look for version in collection variables, default to '1.0.0'\n  const version = (collection.variable?.find((v) => v.key === 'version')?.value as string) || '1.0.0'\n\n  // Handle different description formats in Postman\n  const description =\n    typeof collection.info.description === 'string'\n      ? collection.info.description\n      : collection.info.description?.content || ''\n\n  // Process license and contact information\n  const { license, contact } = processLicenseAndContact(collection)\n\n  // Process logo information\n  const logo = processLogo(collection)\n\n  // Initialize the OpenAPI document with required fields\n  const openapi: OpenAPIV3_1.Document = {\n    openapi: '3.1.0',\n    info: {\n      title,\n      version,\n      ...(description && { description }),\n      ...(license && { license }),\n      ...(contact && { contact }),\n      ...(logo && { 'x-logo': logo }),\n    },\n    servers: parseServers(collection),\n    paths: {},\n  }\n\n  // Process external docs\n  const externalDocs = processExternalDocs(collection)\n  if (externalDocs) {\n    openapi.externalDocs = externalDocs\n  }\n\n  // Process authentication if present in the collection\n  if (collection.auth) {\n    const { securitySchemes, security } = processAuth(collection.auth)\n    openapi.components = openapi.components || {}\n    openapi.components.securitySchemes = {\n      ...openapi.components.securitySchemes,\n      ...securitySchemes,\n    }\n    openapi.security = security\n  }\n\n  // Process each item in the collection and merge into OpenAPI spec\n  if (collection.item) {\n    // Extract tags from folders\n    const tags = extractTags(collection.item)\n    if (tags.length > 0) {\n      openapi.tags = tags\n    }\n\n    collection.item.forEach((item) => {\n      const { paths: itemPaths, components: itemComponents } = processItem(item)\n\n      // Merge paths from the current item\n      openapi.paths = openapi.paths || {}\n      for (const [pathKey, pathItem] of Object.entries(itemPaths)) {\n        // Convert colon-style params to curly brace style\n        const normalizedPathKey = normalizePath(pathKey)\n\n        if (!pathItem) {\n          continue\n        }\n\n        if (!openapi.paths[normalizedPathKey]) {\n          openapi.paths[normalizedPathKey] = pathItem\n        } else {\n          openapi.paths[normalizedPathKey] = {\n            ...openapi.paths[normalizedPathKey],\n            ...pathItem,\n          }\n        }\n      }\n\n      // Merge security schemes from the current item\n      if (itemComponents?.securitySchemes) {\n        openapi.components = openapi.components || {}\n        openapi.components.securitySchemes = {\n          ...openapi.components.securitySchemes,\n          ...itemComponents.securitySchemes,\n        }\n      }\n    })\n  }\n\n  // Clean up the generated paths\n  if (openapi.paths) {\n    Object.values(openapi.paths).forEach((path) => {\n      if (path) {\n        Object.values(path).forEach((method) => {\n          if (method && 'parameters' in method) {\n            // Remove empty parameters array to keep spec clean\n            if (method.parameters?.length === 0) {\n              delete method.parameters\n            }\n\n            // Handle request bodies\n            if (method.requestBody?.content) {\n              const content = method.requestBody.content\n              if (Object.keys(content).length === 0) {\n                // Keep an empty requestBody with text/plain content\n                method.requestBody = {\n                  content: {\n                    'text/plain': {},\n                  },\n                }\n              } else if ('text/plain' in content) {\n                // Preserve schema if it exists, otherwise keep an empty object\n                if (!content['text/plain'].schema || Object.keys(content['text/plain'].schema).length === 0) {\n                  content['text/plain'] = {}\n                }\n              }\n            }\n\n            // Ensure all methods have a description, but don't add an empty one if it doesn't exist\n            if (!method.description) {\n              delete method.description\n            }\n          }\n        })\n      }\n    })\n  }\n\n  // Remove empty components object\n  if (Object.keys(openapi.components || {}).length === 0) {\n    delete openapi.components\n  }\n\n  // Remove undefined properties recursively\n  const removeUndefined = (obj: any): any => {\n    if (Array.isArray(obj)) {\n      return obj.map(removeUndefined).filter((item) => item !== undefined)\n    }\n\n    if (obj && typeof obj === 'object') {\n      return Object.fromEntries(\n        Object.entries(obj)\n          .map(([key, value]) => [key, removeUndefined(value)])\n          .filter(([_, value]) => value !== undefined),\n      )\n    }\n\n    return obj\n  }\n\n  return removeUndefined(openapi)\n}\n"],
  "mappings": "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",
  "names": []
}
