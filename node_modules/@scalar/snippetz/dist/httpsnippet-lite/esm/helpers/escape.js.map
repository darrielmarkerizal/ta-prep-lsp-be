{
  "version": 3,
  "sources": ["../../../../src/httpsnippet-lite/esm/helpers/escape.ts"],
  "sourcesContent": ["// @ts-nocheck\n/**\n * Escape characters within a value to make it safe to insert directly into a\n * snippet. Takes options which define the escape requirements.\n *\n * This is closely based on the JSON-stringify string serialization algorithm,\n * but generalized for other string delimiters (e.g. \" or ') and different escape\n * characters (e.g. Powershell uses `)\n *\n * See https://tc39.es/ecma262/multipage/structured-data.html#sec-quotejsonstring\n * for the complete original algorithm.\n */\nexport function escapeString(rawValue, options = {}) {\n  const { delimiter = '\"', escapeChar = '\\\\', escapeNewlines = true } = options\n  const stringValue = rawValue.toString()\n  return [...stringValue]\n    .map((c) => {\n      if (c === '\\b') {\n        return `${escapeChar}b`\n      }if (c === '\\t') {\n        return `${escapeChar}t`\n      }if (c === '\\n') {\n        if (escapeNewlines) {\n          return `${escapeChar}n`\n        }\n        return c // Don't just continue, or this is caught by < \\u0020\n      }if (c === '\\f') {\n        return `${escapeChar}f`\n      }if (c === '\\r') {\n        if (escapeNewlines) {\n          return `${escapeChar}r`\n        }\n        return c // Don't just continue, or this is caught by < \\u0020\n      }if (c === escapeChar) {\n        return escapeChar + escapeChar\n      }if (c === delimiter) {\n        return escapeChar + delimiter\n      }if (c < '\\u0020' || c > '\\u007E') {\n        // Delegate the trickier non-ASCII cases to the normal algorithm. Some of these\n        // are escaped as \\uXXXX, whilst others are represented literally. Since we're\n        // using this primarily for header values that are generally (though not 100%\n        // strictly?) ASCII-only, this should almost never happen.\n        return JSON.stringify(c).slice(1, -1)\n      }\n      return c\n    })\n    .join('')\n}\n/**\n * Make a string value safe to insert literally into a snippet within single quotes,\n * by escaping problematic characters, including single quotes inside the string,\n * backslashes, newlines, and other special characters.\n *\n * If value is not a string, it will be stringified with .toString() first.\n */\nexport const escapeForSingleQuotes = (value) =>\n  escapeString(value, { delimiter: \"'\" })\n/**\n * Make a string value safe to insert literally into a snippet within double quotes,\n * by escaping problematic characters, including double quotes inside the string,\n * backslashes, newlines, and other special characters.\n *\n * If value is not a string, it will be stringified with .toString() first.\n */\nexport const escapeForDoubleQuotes = (value) =>\n  escapeString(value, { delimiter: '\"' })\n"],
  "mappings": "AAYO,SAAS,aAAa,UAAU,UAAU,CAAC,GAAG;AACnD,QAAM,EAAE,YAAY,KAAK,aAAa,MAAM,iBAAiB,KAAK,IAAI;AACtE,QAAM,cAAc,SAAS,SAAS;AACtC,SAAO,CAAC,GAAG,WAAW,EACnB,IAAI,CAAC,MAAM;AACV,QAAI,MAAM,MAAM;AACd,aAAO,GAAG,UAAU;AAAA,IACtB;AAAC,QAAI,MAAM,KAAM;AACf,aAAO,GAAG,UAAU;AAAA,IACtB;AAAC,QAAI,MAAM,MAAM;AACf,UAAI,gBAAgB;AAClB,eAAO,GAAG,UAAU;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AAAC,QAAI,MAAM,MAAM;AACf,aAAO,GAAG,UAAU;AAAA,IACtB;AAAC,QAAI,MAAM,MAAM;AACf,UAAI,gBAAgB;AAClB,eAAO,GAAG,UAAU;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AAAC,QAAI,MAAM,YAAY;AACrB,aAAO,aAAa;AAAA,IACtB;AAAC,QAAI,MAAM,WAAW;AACpB,aAAO,aAAa;AAAA,IACtB;AAAC,QAAI,IAAI,OAAY,IAAI,KAAU;AAKjC,aAAO,KAAK,UAAU,CAAC,EAAE,MAAM,GAAG,EAAE;AAAA,IACtC;AACA,WAAO;AAAA,EACT,CAAC,EACA,KAAK,EAAE;AACZ;AAQO,MAAM,wBAAwB,CAAC,UACpC,aAAa,OAAO,EAAE,WAAW,IAAI,CAAC;AAQjC,MAAM,wBAAwB,CAAC,UACpC,aAAa,OAAO,EAAE,WAAW,IAAI,CAAC;",
  "names": []
}
