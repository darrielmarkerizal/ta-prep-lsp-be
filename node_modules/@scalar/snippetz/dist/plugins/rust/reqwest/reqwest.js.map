{
  "version": 3,
  "sources": ["../../../../src/plugins/rust/reqwest/reqwest.ts"],
  "sourcesContent": ["import type { Plugin } from '@scalar/types/snippetz'\nimport { toRustString } from '../rustString'\n\n/**\n * rust/reqwest plugin for generating Rust reqwest HTTP client code\n */\nexport const rustReqwest: Plugin = {\n  target: 'rust',\n  client: 'reqwest',\n  title: 'reqwest',\n  generate(request, options?: { auth?: { username: string; password: string } }) {\n    // Normalization\n    const normalizedRequest = normalizeRequest(request)\n\n    // Query string\n    const queryString = buildQueryString(normalizedRequest.queryString)\n    const url = buildUrl(normalizedRequest.url, queryString)\n\n    // Headers and cookies\n    const headers = processHeaders(normalizedRequest)\n\n    // Chained calls\n    const chainedCalls: string[] = []\n\n    // Auth\n    const authCall = createAuthCall(options?.auth)\n    if (authCall) {\n      chainedCalls.push(authCall)\n    }\n\n    // Headers\n    chainedCalls.push(...createHeaderCalls(headers))\n\n    // Body\n    const bodyCall = createBodyCall(normalizedRequest.postData)\n    if (bodyCall) {\n      chainedCalls.push(bodyCall)\n    }\n\n    // Code\n    return buildRustCode(url, normalizedRequest.method, chainedCalls)\n  },\n}\n\n/**\n * Helper function to create indented strings\n */\nconst indent = (level: number, text: string): string => {\n  const spaces = ' '.repeat(level * 4)\n  return `${spaces}${text}`\n}\n\n/**\n * Helper function to create chained method calls with consistent indentation\n */\nconst createChainedCall = (method: string, ...args: string[]): string => {\n  return indent(1, `.${method}(${args.join(', ')})`)\n}\n\n/**\n * Helper function to create multipart form parts with proper indentation\n */\nconst createMultipartPart = (param: { name: string; value?: string; fileName?: string }): string => {\n  if (param.fileName) {\n    return [\n      indent(2, `let part = reqwest::multipart::Part::text(${toRustString(param.value || '')})`),\n      indent(3, `.file_name(${toRustString(param.fileName)});`),\n      indent(2, `form = form.part(${toRustString(param.name)}, part);`),\n    ].join('\\n')\n  }\n\n  return indent(2, `form = form.text(${toRustString(param.name)}, ${toRustString(param.value || '')});`)\n}\n\n/**\n * Formats JSON for Rust's serde_json::json! macro with proper indentation\n */\nconst formatJsonForRust = (jsonText: string): string => {\n  try {\n    const jsonData = JSON.parse(jsonText)\n    const prettyJson = JSON.stringify(jsonData, null, 4)\n\n    // Split into lines and add proper indentation for Rust\n    const lines = prettyJson.split('\\n')\n    const rustLines = lines.map((line, index) => {\n      if (index === 0) {\n        // First line (opening brace)\n        return line\n      }\n      if (index === lines.length - 1) {\n        // Last line (closing brace)\n        return indent(1, line)\n      }\n      // Middle lines\n      return indent(1, line)\n    })\n\n    return rustLines.join('\\n')\n  } catch {\n    // If JSON parsing fails, return the original text\n    return jsonText\n  }\n}\n\n/**\n * Normalizes the request object with defaults\n */\nconst normalizeRequest = (request: any) => {\n  return {\n    ...request,\n    method: (request.method || 'GET').toUpperCase(),\n  }\n}\n\n/**\n * Builds the query string from request parameters\n */\nconst buildQueryString = (queryParams?: Array<{ name: string; value: string }>): string => {\n  if (!queryParams?.length) {\n    return ''\n  }\n\n  const queryPairs = queryParams.map((param) => `${encodeURIComponent(param.name)}=${encodeURIComponent(param.value)}`)\n  return `?${queryPairs.join('&')}`\n}\n\n/**\n * Builds the complete URL with query string\n */\nconst buildUrl = (baseUrl: string, queryString: string): string => {\n  return `${baseUrl}${queryString}`\n}\n\n/**\n * Processes headers and cookies into a headers object\n */\nconst processHeaders = (request: any): Record<string, string> => {\n  const headers: Record<string, string> = {}\n\n  // Process regular headers\n  if (request.headers) {\n    for (const header of request.headers) {\n      if (header.value && !/[; ]/.test(header.name)) {\n        headers[header.name] = header.value\n      }\n    }\n  }\n\n  // Process cookies\n  if (request.cookies?.length > 0) {\n    const cookieString = request.cookies\n      .map((cookie: any) => `${encodeURIComponent(cookie.name)}=${encodeURIComponent(cookie.value)}`)\n      .join('; ')\n    headers['Cookie'] = cookieString\n  }\n\n  return headers\n}\n\n/**\n * Creates authentication chained call if credentials are provided\n */\nconst createAuthCall = (auth?: { username: string; password: string }): string | null => {\n  if (!auth?.username || !auth?.password) {\n    return null\n  }\n\n  return createChainedCall('basic_auth', toRustString(auth.username), toRustString(auth.password))\n}\n\n/**\n * Creates header chained calls from headers object\n */\nconst createHeaderCalls = (headers: Record<string, string>): string[] => {\n  return Object.entries(headers).map(([key, value]) =>\n    createChainedCall('header', toRustString(key), toRustString(value)),\n  )\n}\n\n/**\n * Creates body chained call based on content type\n */\nconst createBodyCall = (postData: any): string | null => {\n  if (!postData) {\n    return null\n  }\n\n  const { mimeType, text, params } = postData\n\n  switch (mimeType) {\n    case 'application/json': {\n      const formattedJson = formatJsonForRust(text)\n      return createChainedCall('json', `&serde_json::json!(${formattedJson})`)\n    }\n\n    case 'application/x-www-form-urlencoded': {\n      const formData =\n        params?.map((param: any) => `(${toRustString(param.name)}, ${toRustString(param.value || '')})`).join(', ') ||\n        ''\n      return createChainedCall('form', `&[${formData}]`)\n    }\n\n    case 'multipart/form-data': {\n      const formParts = params?.map(createMultipartPart).join('\\n') || ''\n      const multipartBlock = [\n        '.multipart({',\n        indent(2, 'let mut form = reqwest::multipart::Form::new();'),\n        formParts,\n        indent(3, 'form'),\n        indent(2, '})'),\n      ].join('\\n')\n      return indent(1, multipartBlock)\n    }\n\n    default:\n      return createChainedCall('body', toRustString(text || ''))\n  }\n}\n\n/**\n * Builds the complete Rust code by assembling all code\n */\nconst buildRustCode = (url: string, method: string, chainedCalls: string[]): string => {\n  const code = ['let client = reqwest::Client::new();', '']\n\n  // Add chained calls with proper formatting\n  if (chainedCalls.length > 0) {\n    code.push('let request = client')\n    code.push(indent(1, `.${method.toLowerCase()}(${toRustString(url)})`))\n\n    // Add a newline before the first chained call\n    code.push(...chainedCalls)\n  } else {\n    code.push(`let request = client.${method.toLowerCase()}(${toRustString(url)})`)\n  }\n\n  // Add semicolon to the last chained call\n  const lastPart = code[code.length - 1]\n  code[code.length - 1] = lastPart + ';'\n\n  // Add response handling\n  code.push('')\n  code.push('let response = request.send().await?;')\n\n  return code.join('\\n')\n}\n"],
  "mappings": "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",
  "names": []
}
