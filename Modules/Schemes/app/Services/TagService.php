<?php

namespace Modules\Schemes\Services;

use Illuminate\Contracts\Pagination\LengthAwarePaginator;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Support\Collection as BaseCollection;
use Illuminate\Support\Str;
use Modules\Schemes\Models\Course;
use Modules\Schemes\Models\Tag;
use Spatie\QueryBuilder\AllowedFilter;
use Spatie\QueryBuilder\QueryBuilder;

class TagService
{
    /**
     * List tags with Spatie Query Builder.
     *
     * Supports:
     * - filter[name], filter[slug], filter[description]
     * - filter[search] for global search
     * - sort: name, slug, created_at, updated_at (prefix with - for desc)
     */
    public function list(int $perPage = 0): LengthAwarePaginator|Collection
    {
        $query = $this->buildQuery();

        if ($perPage > 0) {
            return $query->paginate($perPage);
        }

        return $query->get();
    }

    /**
     * Build query with Spatie Query Builder + Scout search.
     */
    private function buildQuery(): QueryBuilder
    {
        $searchQuery = request('filter.search');

        $builder = QueryBuilder::for(Tag::class);

        // If search query exists, use Scout to get matching IDs
        if ($searchQuery && trim($searchQuery) !== '') {
            $ids = Tag::search($searchQuery)->keys()->toArray();
            $builder->whereIn('id', $ids);
        }

        return $builder
            ->allowedFilters([
                AllowedFilter::partial('name'),
                AllowedFilter::partial('slug'),
                AllowedFilter::partial('description'),
            ])
            ->allowedSorts(['name', 'slug', 'created_at', 'updated_at'])
            ->defaultSort('name');
    }

    public function create(array $data): Tag
    {
        $name = trim((string) ($data['name'] ?? ''));

        return $this->firstOrCreateByName($name);
    }

    /**
     * @param  array<int, string>  $names
     * @return \Illuminate\Support\Collection<int, Tag>
     */
    public function createMany(array $names): BaseCollection
    {
        return BaseCollection::make($names)
            ->map(fn ($name) => trim((string) $name))
            ->filter(fn ($name) => $name !== '')
            ->map(fn ($name) => $this->firstOrCreateByName($name))
            ->values();
    }

    public function update(int $id, array $data): ?Tag
    {
        $tag = Tag::find($id);
        if (! $tag) {
            return null;
        }

        $payload = $this->preparePayload($data, $tag->id, $tag->slug, $tag->name);
        $tag->fill($payload);
        $tag->save();

        return $tag;
    }

    public function delete(int $id): bool
    {
        $tag = Tag::find($id);
        if (! $tag) {
            return false;
        }

        $tag->courses()->detach();

        return (bool) $tag->delete();
    }

    /**
     * Sync the provided tags (slug or name) to the course.
     */
    public function syncCourseTags(Course $course, array $tags): void
    {
        $tagIds = $this->resolveTagIds($tags);

        $course->tags()->sync($tagIds);

        $names = Tag::query()->whereIn('id', $tagIds)->pluck('name')->unique()->values()->toArray();
        $course->tags_json = $names;
        $course->save();
    }

    /**
     * Prepare tag payload - slug is auto-generated by HasSlug trait.
     */
    private function preparePayload(array $data, ?int $ignoreId = null, ?string $currentSlug = null, ?string $currentName = null): array
    {
        $name = trim((string) ($data['name'] ?? ''));

        // Only return name - HasSlug trait handles slug generation
        return [
            'name' => $name,
        ];
    }

    private function firstOrCreateByName(string $name): Tag
    {
        $existing = Tag::query()
            ->whereRaw('LOWER(name) = ?', [mb_strtolower($name)])
            ->first();

        if ($existing) {
            return $existing;
        }

        $payload = $this->preparePayload(['name' => $name]);

        return Tag::create($payload);
    }

    private function ensureUniqueSlug(string $slug, ?int $ignoreId = null): string
    {
        $base = $slug;
        $counter = 1;

        while (Tag::query()
            ->when($ignoreId, fn ($q) => $q->where('id', '!=', $ignoreId))
            ->where('slug', $slug)
            ->exists()
        ) {
            $slug = "{$base}-{$counter}";
            $counter++;
        }

        return $slug;
    }

    /**
     * @param  array<string|int>  $tags
     * @return array<int>
     */
    private function resolveTagIds(array $tags): array
    {
        return BaseCollection::make($tags)
            ->map(function ($tag) {
                if (is_numeric($tag)) {
                    return Tag::query()->where('id', (int) $tag)->value('id');
                }

                $value = trim((string) $tag);
                if ($value === '') {
                    return null;
                }

                $bySlug = Tag::query()
                    ->where('slug', Str::slug($value))
                    ->orWhere('slug', $value)
                    ->first();

                if ($bySlug) {
                    return $bySlug->id;
                }

                $byName = Tag::query()->whereRaw('LOWER(name) = ?', [mb_strtolower($value)])->first();
                if ($byName) {
                    return $byName->id;
                }

                $payload = $this->preparePayload(['name' => $value]);

                return Tag::create($payload)->id;
            })
            ->filter()
            ->unique()
            ->values()
            ->toArray();
    }
}
